/*------------------------------------------------------------------------
 * Vulkan Conformance Tests
 * ------------------------
 *
 * Copyright (c) 2020 The Khronos Group Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *	  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *//*!
 * \file
 * \brief Ray Tracing Misc tests
 *//*--------------------------------------------------------------------*/

#include "vktRayTracingMiscTests.hpp"

#include "vkDefs.hpp"

#include "vktTestCase.hpp"
#include "vkCmdUtil.hpp"
#include "vkObjUtil.hpp"
#include "vkBuilderUtil.hpp"
#include "vkBarrierUtil.hpp"
#include "vkBufferWithMemory.hpp"
#include "vkImageWithMemory.hpp"
#include "vkTypeUtil.hpp"

#include "vkRayTracingUtil.hpp"

#include "deRandom.hpp"

namespace vkt
{
namespace RayTracing
{
namespace
{
using namespace vk;
using namespace std;

enum class GeometryType
{
	FIRST = 0,

	AABB		= FIRST,
	TRIANGLES,

	COUNT,

	AABB_AND_TRIANGLES, //< Only compatible with ONE_TL_MANY_BLS_MANY_GEOMETRIES_WITH_VARYING_PRIM_TYPES AS layout.
};

enum class ShaderGroups
{
	FIRST_GROUP		= 0,
	RAYGEN_GROUP	= FIRST_GROUP,
	MISS_GROUP,
	HIT_GROUP,
	GROUP_COUNT
};

enum class TestType
{
	AABBS_AND_TRIS_IN_ONE_TL,
	AS_STRESS_TEST,
	CULL_MASK,
	MAX_RAY_HIT_ATTRIBUTE_SIZE,
	NO_DUPLICATE_ANY_HIT
};

enum class AccelerationStructureLayout
{
	FIRST = 0,

	ONE_TL_ONE_BL_ONE_GEOMETRY    = FIRST,
	ONE_TL_ONE_BL_MANY_GEOMETRIES,
	ONE_TL_MANY_BLS_ONE_GEOMETRY,
	ONE_TL_MANY_BLS_MANY_GEOMETRIES,

	COUNT,

	ONE_TL_MANY_BLS_MANY_GEOMETRIES_WITH_VARYING_PRIM_TYPES
};

static const VkFlags	ALL_RAY_TRACING_STAGES	= VK_SHADER_STAGE_RAYGEN_BIT_KHR
												| VK_SHADER_STAGE_ANY_HIT_BIT_KHR
												| VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR
												| VK_SHADER_STAGE_MISS_BIT_KHR
												| VK_SHADER_STAGE_INTERSECTION_BIT_KHR
												| VK_SHADER_STAGE_CALLABLE_BIT_KHR;

struct CaseDef
{
	TestType					type;
	GeometryType				geometryType;
	AccelerationStructureLayout	asLayout;
};

/* Helper global functions */
static const char* getSuffixForASLayout(const AccelerationStructureLayout& layout)
{
	const char* result = "?!";

	switch (layout)
	{
		case AccelerationStructureLayout::ONE_TL_ONE_BL_ONE_GEOMETRY:		result = "1TL1BL1G"; break;
		case AccelerationStructureLayout::ONE_TL_ONE_BL_MANY_GEOMETRIES:	result = "1TL1BLnG"; break;
		case AccelerationStructureLayout::ONE_TL_MANY_BLS_ONE_GEOMETRY:		result = "1TLnBL1G"; break;
		case AccelerationStructureLayout::ONE_TL_MANY_BLS_MANY_GEOMETRIES:	result = "1TLnBLnG"; break;

		default:
		{
			deAssertFail("This should never happen", __FILE__, __LINE__);
		}
	}

	return result;
}

static const char* getSuffixForGeometryType(const GeometryType& type)
{
	const char* result = "?!";

	switch (type)
	{
		case GeometryType::AABB:		result = "AABB"; break;
		case GeometryType::TRIANGLES:	result = "tri";  break;

		default:
		{
			deAssertFail("This should never happen", __FILE__, __LINE__);
		}
	}

	return result;
}

/* Instances and primitives in acceleration structures can have additional information assigned.
 *
 * By overriding functions of interest in this class, tests can further customize ASes generated by AS providers.
 */
class ASPropertyProvider
{
public:
	virtual ~ASPropertyProvider()
	{
		/* Stub */
	}

	virtual deUint8 getCullMask(const deUint32& nBL, const deUint32& nInstance) const
	{
		DE_UNREF(nBL);
		DE_UNREF(nInstance);

		return 0xFF;
	}

	virtual deUint32 getInstanceCustomIndex(const deUint32& nBL, const deUint32& nInstance) const
	{
		DE_UNREF(nBL);
		DE_UNREF(nInstance);
		return 0;
	}
};

class IGridASFeedback
{
public:
	virtual ~IGridASFeedback()
	{
		/* Stub */
	}

	virtual void onCullMaskAssignedToCell			(const tcu::UVec3& cellLocation, const deUint8&		cullMaskAssigned)		= 0;
	virtual void onInstanceCustomIndexAssignedToCell(const tcu::UVec3& cellLocation, const deUint32&	customIndexAssigned)	= 0;
};


/* Acceleration structure data providers.
 *
 * These are expected to be reused across different test cases.
 **/
class ASProviderBase
{
public:
	virtual ~ASProviderBase()
	{
		/* Stub */
	}

	virtual std::unique_ptr<TopLevelAccelerationStructure>	createTLAS(		Context&							context,
																			const AccelerationStructureLayout&	asLayout,
																			VkCommandBuffer						cmdBuffer,
																			const VkGeometryFlagsKHR&			bottomLevelGeometryFlags,
																			const ASPropertyProvider*			optAsPropertyProviderPtr	= nullptr,
																			IGridASFeedback*					optASFeedbackPtr			= nullptr)	const = 0;
	virtual deUint32										getNPrimitives()																			const = 0;

};

/* A 3D grid built of primitives. Size and distribution of the geometry can be configured both at creation time and at a later time. */
class GridASProvider : public ASProviderBase
{
public:
	GridASProvider(	const tcu::Vec3&			gridStartXYZ,
					const tcu::Vec3&			gridCellSizeXYZ,
					const tcu::UVec3&			gridSizeXYZ,
					const tcu::Vec3&			gridInterCellDeltaXYZ,
					const GeometryType&			geometryType)
		:m_geometryType			(geometryType),
		 m_gridCellSizeXYZ		(gridCellSizeXYZ),
		 m_gridInterCellDeltaXYZ(gridInterCellDeltaXYZ),
		 m_gridSizeXYZ			(gridSizeXYZ),
		 m_gridStartXYZ			(gridStartXYZ)
	{
		fillVertexVec();
	}

	std::unique_ptr<TopLevelAccelerationStructure> createTLAS(	Context&							context,
																const AccelerationStructureLayout&	asLayout,
																VkCommandBuffer						cmdBuffer,
																const VkGeometryFlagsKHR&			bottomLevelGeometryFlags,
																const ASPropertyProvider*			optASPropertyProviderPtr,
																IGridASFeedback*					optASFeedbackPtr) const final
	{
		Allocator&										allocator				= context.getDefaultAllocator		();
		const DeviceInterface&							deviceInterface			= context.getDeviceInterface		();
		const VkDevice									deviceVk				= context.getDevice					();
		const auto										nCells					= m_gridSizeXYZ.x() * m_gridSizeXYZ.y() * m_gridSizeXYZ.z();
		std::unique_ptr<TopLevelAccelerationStructure>	resultPtr;
		de::MovePtr<TopLevelAccelerationStructure>		tlPtr					= makeTopLevelAccelerationStructure ();

		DE_ASSERT(((asLayout == AccelerationStructureLayout::ONE_TL_MANY_BLS_MANY_GEOMETRIES_WITH_VARYING_PRIM_TYPES) && (m_geometryType == GeometryType::AABB_AND_TRIANGLES)) ||
				  ((asLayout != AccelerationStructureLayout::ONE_TL_MANY_BLS_MANY_GEOMETRIES_WITH_VARYING_PRIM_TYPES) && (m_geometryType != GeometryType::AABB_AND_TRIANGLES)) );

		switch (asLayout)
		{
			case AccelerationStructureLayout::ONE_TL_ONE_BL_ONE_GEOMETRY:
			{
				DE_ASSERT( (m_geometryType == GeometryType::AABB) || (m_geometryType == GeometryType::TRIANGLES) );

				const auto&	vertexVec				= (m_geometryType == GeometryType::AABB)	? m_aabbVertexVec
																								: m_triVertexVec;
				const auto	cullMask				= (optASPropertyProviderPtr != nullptr)		? optASPropertyProviderPtr->getCullMask(0, 0)
																								: static_cast<deUint8>(0xFF);
				const auto	instanceCustomIndex		= (optASPropertyProviderPtr != nullptr)		? optASPropertyProviderPtr->getInstanceCustomIndex(0, 0)
																								: 0;

				tlPtr->setInstanceCount(1);

				{
					de::MovePtr<BottomLevelAccelerationStructure> blPtr = makeBottomLevelAccelerationStructure();

					blPtr->setGeometryCount	(1u);
					blPtr->addGeometry		(vertexVec,
											 (m_geometryType == GeometryType::TRIANGLES),
											 bottomLevelGeometryFlags);

					blPtr->createAndBuild(	deviceInterface,
											deviceVk,
											cmdBuffer,
											allocator);

					tlPtr->addInstance(	de::SharedPtr<BottomLevelAccelerationStructure>(blPtr.release() ),
										identityMatrix3x4,
										instanceCustomIndex,
										cullMask);
				}

				if (optASFeedbackPtr != nullptr)
				{
					for (auto	nCell = 0u;
								nCell < nCells;
								nCell++)
					{
						const auto cellX = (((nCell)												% m_gridSizeXYZ.x() ));
						const auto cellY = (((nCell / m_gridSizeXYZ.x() )							% m_gridSizeXYZ.y() ));
						const auto cellZ = (((nCell / m_gridSizeXYZ.x() )	/ m_gridSizeXYZ.y() )	% m_gridSizeXYZ.z() );

						optASFeedbackPtr->onCullMaskAssignedToCell				(	tcu::UVec3(cellX, cellY, cellZ),
																					cullMask);
						optASFeedbackPtr->onInstanceCustomIndexAssignedToCell	(	tcu::UVec3(cellX, cellY, cellZ),
																					instanceCustomIndex);
					}
				}

				break;
			}

			case AccelerationStructureLayout::ONE_TL_ONE_BL_MANY_GEOMETRIES:
			{
				DE_ASSERT( (m_geometryType == GeometryType::AABB) || (m_geometryType == GeometryType::TRIANGLES) );

				const auto&	vertexVec				= (m_geometryType == GeometryType::AABB)	? m_aabbVertexVec
																								: m_triVertexVec;
				const auto	nVerticesPerPrimitive	= (m_geometryType == GeometryType::AABB)	? 2u
																								: 12u /* tris */  * 3 /* verts */;
				const auto	cullMask				= (optASPropertyProviderPtr != nullptr)		? optASPropertyProviderPtr->getCullMask(0, 0)
																								: static_cast<deUint8>(0xFF);
				const auto	instanceCustomIndex		= (optASPropertyProviderPtr	!= nullptr)		? optASPropertyProviderPtr->getInstanceCustomIndex(0, 0)
																								: 0;

				DE_ASSERT( (vertexVec.size() % nVerticesPerPrimitive) == 0);

				tlPtr->setInstanceCount(1);

				{
					de::MovePtr<BottomLevelAccelerationStructure>	blPtr		= makeBottomLevelAccelerationStructure();
					const auto										nGeometries = vertexVec.size() / nVerticesPerPrimitive;

					blPtr->setGeometryCount	(nGeometries);

					for (deUint32 nGeometry = 0; nGeometry < nGeometries; ++nGeometry)
					{
						std::vector<tcu::Vec3> currentGeometry(nVerticesPerPrimitive);

						for (deUint32 nVertex = 0; nVertex < nVerticesPerPrimitive; ++nVertex)
						{
							currentGeometry.at(nVertex) = vertexVec.at(nGeometry * nVerticesPerPrimitive + nVertex);
						}

						blPtr->addGeometry	(currentGeometry,
											 (m_geometryType == GeometryType::TRIANGLES),
											 bottomLevelGeometryFlags);
					}

					blPtr->createAndBuild(	deviceInterface,
											deviceVk,
											cmdBuffer,
											allocator);

					tlPtr->addInstance(	de::SharedPtr<BottomLevelAccelerationStructure>(blPtr.release() ),
										identityMatrix3x4,
										instanceCustomIndex,
										cullMask);
				}

				if (optASFeedbackPtr != nullptr)
				{
					for (auto	nCell = 0u;
								nCell < nCells;
								nCell++)
					{
						const auto cellX = (((nCell)												% m_gridSizeXYZ.x() ));
						const auto cellY = (((nCell / m_gridSizeXYZ.x() )							% m_gridSizeXYZ.y() ));
						const auto cellZ = (((nCell / m_gridSizeXYZ.x() )	/ m_gridSizeXYZ.y() )	% m_gridSizeXYZ.z() );

						optASFeedbackPtr->onCullMaskAssignedToCell				(	tcu::UVec3(cellX, cellY, cellZ),
																					cullMask);
						optASFeedbackPtr->onInstanceCustomIndexAssignedToCell	(	tcu::UVec3(cellX, cellY, cellZ),
																					instanceCustomIndex);
					}
				}

				break;
			}

			case AccelerationStructureLayout::ONE_TL_MANY_BLS_ONE_GEOMETRY:
			{
				DE_ASSERT( (m_geometryType == GeometryType::AABB) || (m_geometryType == GeometryType::TRIANGLES) );

				const auto&	vertexVec				= (m_geometryType == GeometryType::AABB)	? m_aabbVertexVec
																								: m_triVertexVec;
				const auto	nVerticesPerPrimitive	= (m_geometryType == GeometryType::AABB)	? 2u
																								: 12u /* tris */  * 3 /* verts */;
				const auto	nInstances				= vertexVec.size() / nVerticesPerPrimitive;

				DE_ASSERT( (vertexVec.size() % nVerticesPerPrimitive) == 0);

				tlPtr->setInstanceCount(nInstances);

				for (deUint32 nInstance = 0; nInstance < nInstances; nInstance++)
				{
					de::MovePtr<BottomLevelAccelerationStructure>	blPtr						= makeBottomLevelAccelerationStructure();
					const auto										cullMask					= (optASPropertyProviderPtr != nullptr)	? optASPropertyProviderPtr->getCullMask(0, nInstance)
																																		: static_cast<deUint8>(0xFF);
					std::vector<tcu::Vec3>							currentInstanceVertexVec;
					const auto										instanceCustomIndex			= (optASPropertyProviderPtr != nullptr)	? optASPropertyProviderPtr->getInstanceCustomIndex(0, nInstance)
																																		: 0;

					for (deUint32 nVertex = 0; nVertex < nVerticesPerPrimitive; ++nVertex)
					{
						currentInstanceVertexVec.push_back(vertexVec.at(nInstance * nVerticesPerPrimitive + nVertex) );
					}

					blPtr->setGeometryCount	(1u);
					blPtr->addGeometry		(currentInstanceVertexVec,
											 (m_geometryType == GeometryType::TRIANGLES),
											 bottomLevelGeometryFlags);

					blPtr->createAndBuild(	deviceInterface,
											deviceVk,
											cmdBuffer,
											allocator);

					tlPtr->addInstance(	de::SharedPtr<BottomLevelAccelerationStructure>(blPtr.release() ),
										identityMatrix3x4,
										instanceCustomIndex,
										cullMask);


					if (optASFeedbackPtr != nullptr)
					{
						const auto cellX = (((nInstance)												% m_gridSizeXYZ.x() ));
						const auto cellY = (((nInstance / m_gridSizeXYZ.x() )							% m_gridSizeXYZ.y() ));
						const auto cellZ = (((nInstance / m_gridSizeXYZ.x() )	/ m_gridSizeXYZ.y() )	% m_gridSizeXYZ.z() );

						optASFeedbackPtr->onCullMaskAssignedToCell(				tcu::UVec3(cellX, cellY, cellZ),
																				cullMask);
						optASFeedbackPtr->onInstanceCustomIndexAssignedToCell(	tcu::UVec3(cellX, cellY, cellZ),
																				instanceCustomIndex);
					}
				}

				break;
			}

			case AccelerationStructureLayout::ONE_TL_MANY_BLS_MANY_GEOMETRIES:
			{
				DE_ASSERT( (m_geometryType == GeometryType::AABB) || (m_geometryType == GeometryType::TRIANGLES) );

				const auto&	vertexVec				= (m_geometryType == GeometryType::AABB)	? m_aabbVertexVec
																								: m_triVertexVec;
				const auto	nVerticesPerPrimitive	= (m_geometryType == GeometryType::AABB)	? 2u
																								: 12u /* tris */  * 3 /* verts */;
				const auto	nPrimitivesDefined		= static_cast<deUint32>(vertexVec.size() / nVerticesPerPrimitive);
				const auto	nPrimitivesPerBLAS		= 4;
				const auto	nBottomLevelASes		= nPrimitivesDefined / nPrimitivesPerBLAS;

				DE_ASSERT( (vertexVec.size()   % nVerticesPerPrimitive)	== 0);
				DE_ASSERT( (nPrimitivesDefined % nPrimitivesPerBLAS)	== 0);

				tlPtr->setInstanceCount(nBottomLevelASes);

				for (deUint32 nBottomLevelAS = 0; nBottomLevelAS < nBottomLevelASes; nBottomLevelAS++)
				{
					de::MovePtr<BottomLevelAccelerationStructure>	blPtr				= makeBottomLevelAccelerationStructure();
					const auto										cullMask			= (optASPropertyProviderPtr != nullptr)	? optASPropertyProviderPtr->getCullMask(nBottomLevelAS, 0)
																																: static_cast<deUint8>(0xFF);
					const auto										instanceCustomIndex	= (optASPropertyProviderPtr != nullptr)	? optASPropertyProviderPtr->getInstanceCustomIndex(nBottomLevelAS, 0)
																																: 0;

					blPtr->setGeometryCount(nPrimitivesPerBLAS);

					for (deUint32 nGeometry = 0; nGeometry < nPrimitivesPerBLAS; nGeometry++)
					{
						std::vector<tcu::Vec3> currentVertexVec;

						for (deUint32 nVertex = 0; nVertex < nVerticesPerPrimitive; ++nVertex)
						{
							currentVertexVec.push_back(vertexVec.at((nBottomLevelAS * nPrimitivesPerBLAS + nGeometry) * nVerticesPerPrimitive + nVertex) );
						}

						blPtr->addGeometry(	currentVertexVec,
											(m_geometryType == GeometryType::TRIANGLES),
											bottomLevelGeometryFlags);
					}

					blPtr->createAndBuild(	deviceInterface,
											deviceVk,
											cmdBuffer,
											allocator);
					tlPtr->addInstance(		de::SharedPtr<BottomLevelAccelerationStructure>(blPtr.release() ),
											identityMatrix3x4,
											instanceCustomIndex,
											cullMask);

					if (optASFeedbackPtr != nullptr)
					{
						for (deUint32 cellIndex = nPrimitivesPerBLAS * nBottomLevelAS; cellIndex < nPrimitivesPerBLAS * (nBottomLevelAS + 1); cellIndex++)
						{
							const auto cellX = (((cellIndex)												% m_gridSizeXYZ.x() ));
							const auto cellY = (((cellIndex / m_gridSizeXYZ.x() )							% m_gridSizeXYZ.y() ));
							const auto cellZ = (((cellIndex / m_gridSizeXYZ.x() )	/ m_gridSizeXYZ.y() )	% m_gridSizeXYZ.z() );

							optASFeedbackPtr->onCullMaskAssignedToCell				(	tcu::UVec3(cellX, cellY, cellZ),
																						cullMask);
							optASFeedbackPtr->onInstanceCustomIndexAssignedToCell	(	tcu::UVec3(cellX, cellY, cellZ),
																						instanceCustomIndex);
						}
					}
				}

				break;
			}

			case AccelerationStructureLayout::ONE_TL_MANY_BLS_MANY_GEOMETRIES_WITH_VARYING_PRIM_TYPES:
			{
				DE_ASSERT(m_geometryType == GeometryType::AABB_AND_TRIANGLES);

				const auto	nCellsDefined		= m_gridSizeXYZ[0] * m_gridSizeXYZ[1] * m_gridSizeXYZ[2];
				const auto	nPrimitivesPerBLAS	= 1;
				const auto	nBottomLevelASes	= nCellsDefined / nPrimitivesPerBLAS;

				DE_ASSERT( (nCellsDefined % nPrimitivesPerBLAS) == 0);

				tlPtr->setInstanceCount(nBottomLevelASes);

				for (deUint32 nBottomLevelAS = 0; nBottomLevelAS < nBottomLevelASes; nBottomLevelAS++)
				{
					de::MovePtr<BottomLevelAccelerationStructure>	blPtr					= makeBottomLevelAccelerationStructure();
					const auto										cullMask				= (optASPropertyProviderPtr != nullptr)		? optASPropertyProviderPtr->getCullMask(nBottomLevelAS, 0)
																																		: static_cast<deUint8>(0xFF);
					const auto										instanceCustomIndex		= (optASPropertyProviderPtr != nullptr)		? optASPropertyProviderPtr->getInstanceCustomIndex(nBottomLevelAS, 0)
																																		: 0;
					const bool										usesAABB				= (nBottomLevelAS % 2) == 0;
					const auto&										vertexVec				= (usesAABB)								? m_aabbVertexVec
																																		: m_triVertexVec;
					const auto										nVerticesPerPrimitive	= (usesAABB)								? 2u
																																		: 12u /* tris */  * 3 /* verts */;

					blPtr->setGeometryCount(nPrimitivesPerBLAS);

					for (deUint32 nGeometry = 0; nGeometry < nPrimitivesPerBLAS; nGeometry++)
					{
						DE_ASSERT( (vertexVec.size() % nVerticesPerPrimitive) == 0);

						std::vector<tcu::Vec3> currentVertexVec;

						for (deUint32 nVertex = 0; nVertex < nVerticesPerPrimitive; ++nVertex)
						{
							currentVertexVec.push_back(vertexVec.at((nBottomLevelAS * nPrimitivesPerBLAS + nGeometry) * nVerticesPerPrimitive + nVertex) );
						}

						blPtr->addGeometry(	currentVertexVec,
											!usesAABB,
											bottomLevelGeometryFlags);
					}

					blPtr->createAndBuild	(	deviceInterface,
												deviceVk,
												cmdBuffer,
												allocator);

					tlPtr->addInstance(	de::SharedPtr<BottomLevelAccelerationStructure>(blPtr.release() ),
										identityMatrix3x4,
										instanceCustomIndex,
										cullMask);

					if (optASFeedbackPtr != nullptr)
					{
						for (deUint32 cellIndex = nPrimitivesPerBLAS * nBottomLevelAS; cellIndex < nPrimitivesPerBLAS * (nBottomLevelAS + 1); cellIndex++)
						{
							const auto cellX = (((cellIndex)												% m_gridSizeXYZ.x() ));
							const auto cellY = (((cellIndex / m_gridSizeXYZ.x() )							% m_gridSizeXYZ.y() ));
							const auto cellZ = (((cellIndex / m_gridSizeXYZ.x() )	/ m_gridSizeXYZ.y() )	% m_gridSizeXYZ.z() );

							optASFeedbackPtr->onCullMaskAssignedToCell				(	tcu::UVec3(cellX, cellY, cellZ),
																						cullMask);
							optASFeedbackPtr->onInstanceCustomIndexAssignedToCell	(	tcu::UVec3(cellX, cellY, cellZ),
																						instanceCustomIndex);
						}
					}
				}

				break;
			}

			default:
			{
				deAssertFail("This should never happen", __FILE__, __LINE__);
			}
		}

		tlPtr->createAndBuild(	deviceInterface,
								deviceVk,
								cmdBuffer,
								allocator);

		resultPtr = decltype(resultPtr)(tlPtr.release() );
		return resultPtr;
	}

	deUint32 getNPrimitives() const final
	{
		return m_gridSizeXYZ[0] * m_gridSizeXYZ[1] * m_gridSizeXYZ[2];
	}

	void setProperties(	const tcu::Vec3&		gridStartXYZ,
						const tcu::Vec3&		gridCellSizeXYZ,
						const tcu::UVec3&		gridSizeXYZ,
						const tcu::Vec3&		gridInterCellDeltaXYZ,
						const GeometryType&		geometryType)
	{
		m_gridStartXYZ			= gridStartXYZ;
		m_gridCellSizeXYZ		= gridCellSizeXYZ;
		m_gridSizeXYZ			= gridSizeXYZ;
		m_gridInterCellDeltaXYZ = gridInterCellDeltaXYZ;
		m_geometryType			= geometryType;

		fillVertexVec();
	}

private:
	void fillVertexVec()
	{
		const auto nCellsNeeded = m_gridSizeXYZ.x() * m_gridSizeXYZ.y() * m_gridSizeXYZ.z();

		m_aabbVertexVec.clear();
		m_triVertexVec.clear ();

		for (auto	nCell = 0u;
					nCell < nCellsNeeded;
					nCell++)
		{
			const auto cellX = (((nCell)												% m_gridSizeXYZ.x() ));
			const auto cellY = (((nCell / m_gridSizeXYZ.x() )							% m_gridSizeXYZ.y() ));
			const auto cellZ = (((nCell / m_gridSizeXYZ.x() )	/ m_gridSizeXYZ.y() )	% m_gridSizeXYZ.z() );

			const auto cellX1Y1Z1 = tcu::Vec3(	m_gridStartXYZ.x() + static_cast<float>(cellX) * m_gridInterCellDeltaXYZ.x(),
												m_gridStartXYZ.y() + static_cast<float>(cellY) * m_gridInterCellDeltaXYZ.y(),
												m_gridStartXYZ.z() + static_cast<float>(cellZ) * m_gridInterCellDeltaXYZ.z() );
			const auto cellX2Y2Z2 = tcu::Vec3(	m_gridStartXYZ.x() + static_cast<float>(cellX) * m_gridInterCellDeltaXYZ.x() + m_gridCellSizeXYZ.x(),
												m_gridStartXYZ.y() + static_cast<float>(cellY) * m_gridInterCellDeltaXYZ.y() + m_gridCellSizeXYZ.y(),
												m_gridStartXYZ.z() + static_cast<float>(cellZ) * m_gridInterCellDeltaXYZ.z() + m_gridCellSizeXYZ.z() );

			if (m_geometryType == GeometryType::AABB				||
				m_geometryType == GeometryType::AABB_AND_TRIANGLES)
			{
				/* Cell = AABB of the cell */
				m_aabbVertexVec.push_back(cellX1Y1Z1);
				m_aabbVertexVec.push_back(cellX2Y2Z2);
			}

			if (m_geometryType == GeometryType::AABB_AND_TRIANGLES ||
				m_geometryType == GeometryType::TRIANGLES)
			{
				/* Cell == Six triangles forming a cube
				 *
				 * Lower-case characters: vertices with Z == Z2
				 * Upper-case characters: vertices with Z == Z1


						g				h


				    C              D



						e				f

					A              B


				 */
				const auto A = tcu::Vec3(	cellX1Y1Z1.x(),
											cellX1Y1Z1.y(),
											cellX1Y1Z1.z() );
				const auto B = tcu::Vec3(	cellX2Y2Z2.x(),
											cellX1Y1Z1.y(),
											cellX1Y1Z1.z() );
				const auto C = tcu::Vec3(	cellX1Y1Z1.x(),
											cellX2Y2Z2.y(),
											cellX1Y1Z1.z() );
				const auto D = tcu::Vec3(	cellX2Y2Z2.x(),
											cellX2Y2Z2.y(),
											cellX1Y1Z1.z() );
				const auto E = tcu::Vec3(	cellX1Y1Z1.x(),
											cellX1Y1Z1.y(),
											cellX2Y2Z2.z() );
				const auto F = tcu::Vec3(	cellX2Y2Z2.x(),
											cellX1Y1Z1.y(),
											cellX2Y2Z2.z() );
				const auto G = tcu::Vec3(	cellX1Y1Z1.x(),
											cellX2Y2Z2.y(),
											cellX2Y2Z2.z() );
				const auto H = tcu::Vec3(	cellX2Y2Z2.x(),
											cellX2Y2Z2.y(),
											cellX2Y2Z2.z() );

				// Z = Z1 face
				m_triVertexVec.push_back(A);
				m_triVertexVec.push_back(C);
				m_triVertexVec.push_back(D);

				m_triVertexVec.push_back(D);
				m_triVertexVec.push_back(B);
				m_triVertexVec.push_back(A);

				// Z = Z2 face
				m_triVertexVec.push_back(E);
				m_triVertexVec.push_back(H);
				m_triVertexVec.push_back(G);

				m_triVertexVec.push_back(H);
				m_triVertexVec.push_back(F);
				m_triVertexVec.push_back(E);

				// X = X0 face
				m_triVertexVec.push_back(A);
				m_triVertexVec.push_back(C);
				m_triVertexVec.push_back(G);

				m_triVertexVec.push_back(G);
				m_triVertexVec.push_back(E);
				m_triVertexVec.push_back(A);

				// X = X1 face
				m_triVertexVec.push_back(B);
				m_triVertexVec.push_back(D);
				m_triVertexVec.push_back(H);

				m_triVertexVec.push_back(H);
				m_triVertexVec.push_back(F);
				m_triVertexVec.push_back(B);

				// Y = Y0 face
				m_triVertexVec.push_back(C);
				m_triVertexVec.push_back(D);
				m_triVertexVec.push_back(H);

				m_triVertexVec.push_back(H);
				m_triVertexVec.push_back(G);
				m_triVertexVec.push_back(C);

				// Y = y1 face
				m_triVertexVec.push_back(A);
				m_triVertexVec.push_back(B);
				m_triVertexVec.push_back(E);

				m_triVertexVec.push_back(B);
				m_triVertexVec.push_back(F);
				m_triVertexVec.push_back(E);
			}
		}
	}

	std::vector<tcu::Vec3> m_aabbVertexVec;
	std::vector<tcu::Vec3> m_triVertexVec;

	GeometryType	m_geometryType;
	tcu::Vec3		m_gridCellSizeXYZ;
	tcu::Vec3		m_gridInterCellDeltaXYZ;
	tcu::UVec3		m_gridSizeXYZ;
	tcu::Vec3		m_gridStartXYZ;
};


/* Test logic providers ==> */
class TestBase
{
public:
	virtual ~TestBase()
	{
		/* Stub */
	}

	virtual tcu::UVec3									getDispatchSize				()												const	= 0;
	virtual deUint32									getResultBufferSize			()												const	= 0;
	virtual std::vector<TopLevelAccelerationStructure*>	getTLASPtrVecToBind			()												const	= 0;
	virtual void										resetTLAS					()														= 0;
	virtual void										initAS						(	vkt::Context&			context,
																						RayTracingProperties*	rtPropertiesPtr,
																						VkCommandBuffer			commandBuffer)				= 0;
	virtual void										initPrograms				(	SourceCollections&		programCollection)	const	= 0;
	virtual bool										verifyResultBuffer			(	const void*				inBufferPtr)		const	= 0;

	virtual deUint32 getASBindingArraySize() const
	{
		return 1u;
	}

	virtual deUint32 getNTraceRayInvocationsNeeded() const
	{
		return 1;
	}

	virtual Move<VkPipelineLayout> getPipelineLayout(const vk::DeviceInterface&	deviceInterface,
													 VkDevice					deviceVk,
													 VkDescriptorSetLayout		descriptorSetLayout)
	{
		return makePipelineLayout(	deviceInterface,
									deviceVk,
									descriptorSetLayout);
	}

	virtual VkSpecializationInfo* getSpecializationInfoPtr(const VkShaderStageFlagBits& /* shaderStage */)
	{
		return nullptr;
	}

	virtual bool init(RayTracingProperties* /* rtPropsPtr */)
	{
		return true;
	}

	virtual void onBeforeCmdTraceRays(	const deUint32&		/* nDispatch      */,
										vkt::Context&		/* context        */,
										VkCommandBuffer		/* commandBuffer  */,
										VkPipelineLayout	/* pipelineLayout */)
	{
		/* Stub */
	}
};

class AABBTriTLTest :	public TestBase,
						public ASPropertyProvider
{
public:
	AABBTriTLTest(	const GeometryType&					geometryType,
					const AccelerationStructureLayout&	asStructureLayout)
		:	m_asStructureLayout				(asStructureLayout),
			m_geometryType					(geometryType),
			m_gridSize                      (tcu::UVec3(720, 1, 1) ),
			m_lastCustomInstanceIndexUsed	(0)
	{
	}

	~AABBTriTLTest()
	{
		/* Stub */
	}

	deUint32 getInstanceCustomIndex(const deUint32& nBL, const deUint32& nInstance) const final
	{
		DE_UNREF(nBL);
		DE_UNREF(nInstance);

		return ++m_lastCustomInstanceIndexUsed;
	}

	tcu::UVec3 getDispatchSize() const final
	{
		return tcu::UVec3(m_gridSize[0], m_gridSize[1], m_gridSize[2]);
	}

	deUint32 getResultBufferSize() const final
	{
		return static_cast<deUint32>((2 /* nHits, nMisses */ + m_gridSize[0] * m_gridSize[1] * m_gridSize[2] * 1 /* hit instance custom indices */) * sizeof(deUint32) );
	}

	std::vector<TopLevelAccelerationStructure*>	getTLASPtrVecToBind() const final
	{
		DE_ASSERT(m_tlPtr != nullptr);

		return {m_tlPtr.get() };
	}

	void resetTLAS() final
	{
		m_tlPtr.reset();
	}

	void initAS(vkt::Context&			context,
				RayTracingProperties*	/* rtPropertiesPtr */,
				VkCommandBuffer			commandBuffer) final
	{
		/* Each AS holds a single unit AABB / cube built of tris.
		 *
		 * Geometry in the zeroth acceleration structure starts at the origin. Subsequent ASes
		 * hold geometry that is positioned so that geometry formed by the union of all ASes never
		 * intersects.
		 *
		 * Each raygen shader invocation uses a unique origin+target pair for the traced ray, and
		 * only one AS is expected to hold geometry that the ray can find intersection for.
		 * The AS index is stored in the result buffer, which is later verified by the CPU.
		 *
		 * Due to the fact AccelerationStructureEXT array indexing must be dynamically uniform and
		 * it is not guaranteed we can determine workgroup size on VK 1.1-conformant platforms,
		 * we can only trace rays against the same AS in a single ray trace dispatch.
		 */
		std::unique_ptr<GridASProvider> asProviderPtr(
			new GridASProvider(	tcu::Vec3 (0, 0, 0), /* gridStartXYZ          */
								tcu::Vec3 (1, 1, 1), /* gridCellSizeXYZ       */
								m_gridSize,
								tcu::Vec3 (3, 0, 0), /* gridInterCellDeltaXYZ */
								m_geometryType)
		);

		m_tlPtr  = asProviderPtr->createTLAS(	context,
												m_asStructureLayout,
												commandBuffer,
												VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
												this,		/* optASPropertyProviderPtr */
												nullptr);	/* optASFeedbackPtr			*/
	}

	void initPrograms(SourceCollections& programCollection) const final
	{
		const vk::ShaderBuildOptions	buildOptions(	programCollection.usedVulkanVersion,
														vk::SPIRV_VERSION_1_4,
														0u,		/* flags        */
														true);	/* allowSpirv14 */

		const char* hitPropsDefinition =
			"struct HitProps\n"
			"{\n"
			"    uint instanceCustomIndex;\n"
			"};\n";

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				"hitAttributeEXT vec3 dummyAttribute;\n"
				"\n"
				+ de::toString(hitPropsDefinition) +
				"\n"
				"layout(location = 0) rayPayloadInEXT      uint   dummy;\n"
				"layout(set      = 0, binding = 0, std430) buffer result\n"
				"{\n"
				"    uint     nHitsRegistered;\n"
				"    uint     nMissesRegistered;\n"
				"    HitProps hits[];\n"
				"};\n"
				"\n"
				"void main()\n"
				"{\n"
				"    uint nHit = atomicAdd(nHitsRegistered, 1);\n"
				"\n"
				"    hits[nHit].instanceCustomIndex = gl_InstanceCustomIndexEXT;\n"
				"}\n";

			programCollection.glslSources.add("ahit") << glu::AnyHitSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				"hitAttributeEXT vec3 hitAttribute;\n"
				"\n"
				"void main()\n"
				"{\n"
				"    reportIntersectionEXT(0.95f, 0);\n"
				"}\n";

			programCollection.glslSources.add("intersection") << glu::IntersectionSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				+ de::toString(hitPropsDefinition) +
				"\n"
				"layout(set = 0, binding = 0, std430) buffer result\n"
				"{\n"
				"    uint     nHitsRegistered;\n"
				"    uint     nMissesRegistered;\n"
				"    HitProps hits[];\n"
				"};\n"
				"\n"
				"layout(location = 0) rayPayloadInEXT uint rayIndex;\n"
				"\n"
				"void main()\n"
				"{\n"
				"    atomicAdd(nMissesRegistered, 1);\n"
				"}\n";

			programCollection.glslSources.add("miss") << glu::MissSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				"layout(location = 0)              rayPayloadEXT uint               dummy;\n"
				"layout(set      = 0, binding = 1) uniform accelerationStructureEXT accelerationStructure;\n"
				"\n"
				"void main()\n"
				"{\n"
				"    uint  nInvocation  = gl_LaunchIDEXT.z * gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;\n"
				"    uint  rayFlags     = 0;\n"
				"    float tmin         = 0.001;\n"
				"    float tmax         = 9.0;\n"
				"\n"
				"    uint  cullMask     = 0xFF;\n"
				"    vec3  cellStartXYZ = vec3(nInvocation * 3.0, 0.0, 0.0);\n"
				"    vec3  cellEndXYZ   = cellStartXYZ + vec3(1.0);\n"
				"    vec3  target       = mix(cellStartXYZ, cellEndXYZ, vec3(0.5) );\n"
				"    vec3  origin       = target - vec3(0, 2, 0);\n"
				"    vec3  direct       = normalize(target - origin);\n"
				"\n"
				"    traceRayEXT(accelerationStructure, rayFlags, cullMask, 0, 0, 0, origin, tmin, direct, tmax, 0);\n"
				"}\n";

			programCollection.glslSources.add("rgen") << glu::RaygenSource(css.str() ) << buildOptions;
		}
	}

	bool verifyResultBuffer (const void* resultDataPtr) const final
	{
		const deUint32* resultU32Ptr	= reinterpret_cast<const deUint32*>(resultDataPtr);
		bool			result			= false;

		typedef struct
		{
			deUint32 instanceCustomIndex;
		} HitProperties;

		std::map<deUint32, deUint32>	customInstanceIndexToHitCountMap;
		const auto						nHitsReported						= *resultU32Ptr;
		const auto						nMissesReported						= *(resultU32Ptr + 1);

		if (nHitsReported != m_gridSize[0] * m_gridSize[1] * m_gridSize[2])
		{
			goto end;
		}

		if (nMissesReported != 0)
		{
			goto end;
		}

		for (deUint32 nHit = 0; nHit < nHitsReported; ++nHit)
		{
			const HitProperties* hitPropsPtr = reinterpret_cast<const HitProperties*>(resultU32Ptr + 2 /* preamble ints */) + nHit;

			customInstanceIndexToHitCountMap[hitPropsPtr->instanceCustomIndex]++;

			if (customInstanceIndexToHitCountMap[hitPropsPtr->instanceCustomIndex] > 1)
			{
				goto end;
			}
		}

		for (deUint32 nInstance = 0; nInstance < nHitsReported; ++nInstance)
		{
			if (customInstanceIndexToHitCountMap.find(1 + nInstance) == customInstanceIndexToHitCountMap.end() )
			{
				goto end;
			}
		}

		result = true;
end:
		return result;
	}

private:
	const AccelerationStructureLayout	m_asStructureLayout;
	const GeometryType					m_geometryType;

	const tcu::UVec3								m_gridSize;
	mutable deUint32								m_lastCustomInstanceIndexUsed;
	std::unique_ptr<TopLevelAccelerationStructure>	m_tlPtr;
};

class ASStressTest :	public TestBase,
						public ASPropertyProvider
{
public:
	ASStressTest(	const GeometryType&					geometryType,
					const AccelerationStructureLayout&	asStructureLayout)
		:	m_asStructureLayout				(asStructureLayout),
			m_geometryType					(geometryType),
			m_lastCustomInstanceIndexUsed	(0),
			m_nASesToUse					(0),
			m_nMaxASToUse					(16u)
	{
	}

	~ASStressTest()
	{
		/* Stub */
	}

	deUint32 getASBindingArraySize() const final
	{
		DE_ASSERT(m_nASesToUse != 0);

		return m_nASesToUse;
	}

	deUint32 getInstanceCustomIndex(const deUint32& nBL, const deUint32& nInstance) const final
	{
		DE_UNREF(nBL);
		DE_UNREF(nInstance);

		return ++m_lastCustomInstanceIndexUsed;
	}

	tcu::UVec3 getDispatchSize() const final
	{
		return tcu::UVec3(1, 1, 1);
	}

	deUint32 getNTraceRayInvocationsNeeded() const final
	{
		return m_nMaxASToUse;
	}

	deUint32 getResultBufferSize() const final
	{
		return static_cast<deUint32>((2 /* nHits, nMisses */ + 2 * m_nMaxASToUse /* hit instance custom indices + AS index */) * sizeof(deUint32) );
	}

	std::vector<TopLevelAccelerationStructure*>	getTLASPtrVecToBind() const final
	{
		std::vector<TopLevelAccelerationStructure*> resultVec;

		DE_ASSERT(m_tlPtrVec.size() != 0);

		for (auto& currentTLPtr : m_tlPtrVec)
		{
			resultVec.push_back(currentTLPtr.get() );
		}

		return resultVec;
	}

	void resetTLAS() final
	{
		for (auto& currentTLPtr : m_tlPtrVec)
		{
			currentTLPtr.reset();
		}
	}

	bool init(RayTracingProperties* rtPropertiesPtr) final
	{
		/* NOTE: We clamp the number below to a sensible value, in case the implementation has no restrictions on the number of
		 *		 ASes accessible to shaders.
		 */
		m_nASesToUse = std::min(rtPropertiesPtr->getMaxDescriptorSetAccelerationStructures(),
								m_nMaxASToUse);

		return true;
	}

	void initAS(vkt::Context&			context,
				RayTracingProperties*	/* rtPropertiesPtr */,
				VkCommandBuffer			commandBuffer) final
	{
		/* Each AS holds a single unit AABB / cube built of tris.
		 *
		 * Geometry in the zeroth acceleration structure starts at the origin. Subsequent ASes
		 * hold geometry that is positioned so that geometry formed by the union of all ASes never
		 * intersects.
		 *
		 * Each raygen shader invocation uses a unique origin+target pair for the traced ray, and
		 * only one AS is expected to hold geometry that the ray can find intersection for.
		 * The AS index is stored in the result buffer, which is later verified by the CPU.
		 *
		 * Due to the fact AccelerationStructureEXT array indexing must be dynamically uniform and
		 * it is not guaranteed we can determine workgroup size on VK 1.1-conformant platforms,
		 * we can only trace rays against the same AS in a single ray trace dispatch.
		 */
		std::unique_ptr<GridASProvider> asProviderPtr(
			new GridASProvider(	tcu::Vec3 (0, 0, 0), /* gridStartXYZ          */
								tcu::Vec3 (1, 1, 1), /* gridCellSizeXYZ       */
								tcu::UVec3(1, 1, 1), /* gridSizeXYZ           */
								tcu::Vec3 (0, 0, 0), /* gridInterCellDeltaXYZ */
								m_geometryType)
		);

		for (deUint32 nAS = 0; nAS < m_nASesToUse; ++nAS)
		{
			const auto origin = tcu::Vec3(3.0f * static_cast<float>(nAS), 0.0f, 0.0f);

			asProviderPtr->setProperties(
				origin,
				tcu::Vec3(1, 1, 1),		/* gridCellSizeXYZ       */
				tcu::UVec3(1, 1, 1),	/* gridSizeXYZ           */
				tcu::Vec3(0, 0, 0),		/* gridInterCellDeltaXYZ */
				m_geometryType
			);

			auto tlPtr = asProviderPtr->createTLAS(	context,
													m_asStructureLayout,
													commandBuffer,
													VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
													this,		/* optASPropertyProviderPtr */
													nullptr);	/* optASFeedbackPtr			*/

			m_tlPtrVec.push_back(std::move(tlPtr) );
		}
	}

	void initPrograms(SourceCollections& programCollection) const final
	{
		const vk::ShaderBuildOptions	buildOptions(	programCollection.usedVulkanVersion,
														vk::SPIRV_VERSION_1_4,
														0u,		/* flags        */
														true);	/* allowSpirv14 */

		const char* hitPropsDefinition =
			"struct HitProps\n"
			"{\n"
			"    uint instanceCustomIndex;\n"
			"    uint nAS;\n"
			"};\n";

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				"hitAttributeEXT vec3 dummyAttribute;\n"
				"\n"
				+ de::toString(hitPropsDefinition) +
				"\n"
				"layout(location = 0) rayPayloadInEXT      uint   nAS;\n"
				"layout(set      = 0, binding = 0, std430) buffer result\n"
				"{\n"
				"    uint     nHitsRegistered;\n"
				"    uint     nMissesRegistered;\n"
				"    HitProps hits[];\n"
				"};\n"
				"\n"
				"void main()\n"
				"{\n"
				"    uint nHit = atomicAdd(nHitsRegistered, 1);\n"
				"\n"
				"    hits[nHit].instanceCustomIndex = gl_InstanceCustomIndexEXT;\n"
				"    hits[nHit].nAS                 = nAS;\n"
				"}\n";

			programCollection.glslSources.add("ahit") << glu::AnyHitSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				"hitAttributeEXT vec3 hitAttribute;\n"
				"\n"
				"void main()\n"
				"{\n"
				"    reportIntersectionEXT(0.95f, 0);\n"
				"}\n";

			programCollection.glslSources.add("intersection") << glu::IntersectionSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				+ de::toString(hitPropsDefinition) +
				"\n"
				"layout(set = 0, binding = 0, std430) buffer result\n"
				"{\n"
				"    uint     nHitsRegistered;\n"
				"    uint     nMissesRegistered;\n"
				"    HitProps hits[];\n"
				"};\n"
				"\n"
				"layout(location = 0) rayPayloadInEXT uint rayIndex;\n"
				"\n"
				"void main()\n"
				"{\n"
				"    atomicAdd(nMissesRegistered, 1);\n"
				"}\n";

			programCollection.glslSources.add("miss") << glu::MissSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				"layout(push_constant) uniform pcUB\n"
				"{\n"
				"    uint nAS;\n"
				"} ub;\n"
				"\n"
				"layout(location = 0)              rayPayloadEXT uint               payload;\n"
				"layout(set      = 0, binding = 1) uniform accelerationStructureEXT accelerationStructures[" + de::toString(m_nMaxASToUse) + "];\n"
				"\n"
				"void main()\n"
				"{\n"
				"    uint  nInvocation  = gl_LaunchIDEXT.z * gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;\n"
				"    uint  rayFlags     = 0;\n"
				"    float tmin         = 0.001;\n"
				"    float tmax         = 9.0;\n"
				"\n"
				"    uint  cullMask     = 0xFF;\n"
				"    vec3  cellStartXYZ = vec3(ub.nAS * 3.0, 0.0, 0.0);\n"
				"    vec3  cellEndXYZ   = cellStartXYZ + vec3(1.0);\n"
				"    vec3  target       = mix(cellStartXYZ, cellEndXYZ, vec3(0.5) );\n"
				"    vec3  origin       = target - vec3(0, 2, 0);\n"
				"    vec3  direct       = normalize(target - origin);\n"
				"\n"
				"    payload = ub.nAS;\n"
				"\n"
				"    traceRayEXT(accelerationStructures[ub.nAS], rayFlags, cullMask, 0, 0, 0, origin, tmin, direct, tmax, 0);\n"
				"}\n";

			programCollection.glslSources.add("rgen") << glu::RaygenSource(css.str() ) << buildOptions;
		}
	}

	Move<VkPipelineLayout> getPipelineLayout(	const vk::DeviceInterface&	deviceInterface,
												VkDevice					deviceVk,
												VkDescriptorSetLayout		descriptorSetLayout) final
	{
		VkPushConstantRange pushConstantRange;

		pushConstantRange.offset		= 0;
		pushConstantRange.size			= sizeof(deUint32);
		pushConstantRange.stageFlags	= VK_SHADER_STAGE_RAYGEN_BIT_KHR;

		return makePipelineLayout(	deviceInterface,
									deviceVk,
									1, /* setLayoutCount */
									&descriptorSetLayout,
									1, /* pushRangeCount */
									&pushConstantRange);
	}

	void onBeforeCmdTraceRays(	const deUint32&		nDispatch,
								vkt::Context&		context,
								VkCommandBuffer		commandBuffer,
								VkPipelineLayout	pipelineLayout) final
	{
		/* No need for a sync point in-between trace ray commands - all writes are atomic */
		VkMemoryBarrier memBarrier;

		memBarrier.dstAccessMask	= VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT;
		memBarrier.pNext			= nullptr;
		memBarrier.srcAccessMask	= VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT;;
		memBarrier.sType			= VK_STRUCTURE_TYPE_MEMORY_BARRIER;

		context.getDeviceInterface().cmdPipelineBarrier(commandBuffer,
														VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,	/* srcStageMask       */
														VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,	/* dstStageMask       */
														0,												/* dependencyFlags    */
														1,												/* memoryBarrierCount */
														&memBarrier,
														0,												/* bufferMemoryBarrierCount */
														nullptr,										/* pBufferMemoryBarriers    */
														0,												/* imageMemoryBarrierCount  */
														nullptr);										/* pImageMemoryBarriers     */

		context.getDeviceInterface().cmdPushConstants(	commandBuffer,
														pipelineLayout,
														VK_SHADER_STAGE_RAYGEN_BIT_KHR,
														0, /* offset */
														sizeof(deUint32),
														&nDispatch);
	}

	bool verifyResultBuffer (const void* resultDataPtr) const final
	{
		const deUint32* resultU32Ptr	= reinterpret_cast<const deUint32*>(resultDataPtr);
		bool			result			= false;

		typedef struct
		{
			deUint32 instanceCustomIndex;
			deUint32 nAS;
		} HitProperties;

		const auto		nHitsReported	= *resultU32Ptr;
		const auto		nMissesReported	= *(resultU32Ptr + 1);

		if (nHitsReported != m_nMaxASToUse)
		{
			goto end;
		}

		if (nMissesReported != 0)
		{
			goto end;
		}

		for (deUint32 nHit = 0; nHit < nHitsReported; ++nHit)
		{
			const HitProperties* hitPropsPtr = reinterpret_cast<const HitProperties*>(resultU32Ptr + 2 /* preamble ints */) + nHit;

			if (hitPropsPtr->instanceCustomIndex != (nHit + 1) )
			{
				goto end;
			}

			if (hitPropsPtr->nAS != nHit)
			{
				goto end;
			}
		}

		result = true;
end:
		return result;
	}

private:
	const AccelerationStructureLayout	m_asStructureLayout;
	const GeometryType					m_geometryType;

	mutable deUint32												m_lastCustomInstanceIndexUsed;
	deUint32														m_nASesToUse;
	std::vector<std::unique_ptr<TopLevelAccelerationStructure> >	m_tlPtrVec;

	const deUint32 m_nMaxASToUse;
};


class CullMaskTest :	public TestBase,
						public ASPropertyProvider
{
public:
	CullMaskTest(	const AccelerationStructureLayout&	asLayout,
					const GeometryType&					geometryType)
		:m_asLayout						(asLayout),
		 m_geometryType					(geometryType),
		 m_nMaxHitsToRegister			(256),
		 m_nRaysPerInvocation			(4),
		 m_lastCustomInstanceIndexUsed	(0),
		 m_nCullMasksUsed				(1)
	{
		/* Stub */
	}

	~CullMaskTest()
	{
		/* Stub */
	}

	deUint8 getCullMask(const deUint32& nBL, const deUint32& nInstance) const final
	{
		DE_UNREF(nBL);
		DE_UNREF(nInstance);

		deUint8 result = (m_nCullMasksUsed++) & 0xFF;

		DE_ASSERT(result != 0);
		return result;
	}

	deUint32 getInstanceCustomIndex(const deUint32& nBL, const deUint32& nInstance) const final
	{
		DE_UNREF(nBL);
		DE_UNREF(nInstance);

		/* NOTE: The formula below generates a sequence of unique large values. */
		deUint32 result = (m_lastCustomInstanceIndexUsed * 7 + 153325) & ((1 << 24) - 1);

		if (m_instanceCustomIndexVec.size() <= nInstance)
		{
			m_instanceCustomIndexVec.resize(nInstance + 1);
		}

		m_instanceCustomIndexVec		[nInstance] = result;
		m_lastCustomInstanceIndexUsed				= result;

		return result;
	}

	tcu::UVec3 getDispatchSize() const final
	{
		//< 3*5*17 == 255, which coincidentally is the maximum cull mask value the spec permits.
		//<
		//< This global WG size is excessively large if m_nRaysPerInvocation > 1 but the raygen shader has
		//< a guard condition check that drops extraneous invocations.
		return tcu::UVec3(3, 5, 17);
	}

	deUint32 getResultBufferSize() const final
	{
		return static_cast<deUint32>((1 + m_nMaxHitsToRegister * 2) * sizeof(deUint32) );
	}

	std::vector<TopLevelAccelerationStructure*>	getTLASPtrVecToBind() const	final
	{
		return {m_tlPtr.get() };
	}

	void resetTLAS() final
	{
		m_tlPtr.reset();
	}

	void initAS(vkt::Context&			context,
				RayTracingProperties*	/* rtPropertiesPtr */,
				VkCommandBuffer			commandBuffer) final
	{
		m_asProviderPtr.reset(
				new GridASProvider(	tcu::Vec3	(0,		0,		0),		/* gridStartXYZ          */
									tcu::Vec3	(1,		1,		1),		/* gridCellSizeXYZ       */
									tcu::UVec3	(3,		5,		17),	/* gridSizeXYZ           */
									tcu::Vec3	(2.0f,	2.0f,	2.0f),  /* gridInterCellDeltaXYZ */
									m_geometryType)
			);

		m_tlPtr  = m_asProviderPtr->createTLAS(	context,
												m_asLayout,
												commandBuffer,
												VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
												this,		/* optASPropertyProviderPtr */
												nullptr);	/* optASFeedbackPtr         */
	}

	void initPrograms(SourceCollections& programCollection) const final
	{
		const vk::ShaderBuildOptions	buildOptions(	programCollection.usedVulkanVersion,
														vk::SPIRV_VERSION_1_4,
														0u,		/* flags        */
														true);	/* allowSpirv14 */

		const char* hitPropsDefinition =
			"struct HitProps\n"
			"{\n"
			"    uint rayIndex;\n"
			"    uint instanceCustomIndex;\n"
			"};\n";

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				"hitAttributeEXT vec3 dummyAttribute;\n"
				"\n"
				+ de::toString(hitPropsDefinition) +
				"\n"
				"layout(location = 0) rayPayloadInEXT      uint   nRay;\n"
				"layout(set      = 0, binding = 0, std430) buffer result\n"
				"{\n"
				"    uint     nHitsRegistered;\n"
				"    uint     nMissesRegistered;\n"
				"    HitProps hits[];\n"
				"};\n"
				"\n"
				"void main()\n"
				"{\n"
				"    uint nHit = atomicAdd(nHitsRegistered, 1);\n"
				"\n"
				"    if (nHit < " + de::toString(m_nMaxHitsToRegister) + ")\n"
				"    {\n"
				"        hits[nHit].rayIndex            = nRay;\n"
				"        hits[nHit].instanceCustomIndex = gl_InstanceCustomIndexEXT;\n"
				"    }\n"
				"}\n";

			programCollection.glslSources.add("ahit") << glu::AnyHitSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				"hitAttributeEXT vec3 hitAttribute;\n"
				"\n"
				"void main()\n"
				"{\n"
				"    reportIntersectionEXT(0.95f, 0);\n"
				"}\n";

			programCollection.glslSources.add("intersection") << glu::IntersectionSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				+ de::toString(hitPropsDefinition) +
				"\n"
				"layout(set      = 0, binding = 0, std430) buffer result\n"
				"{\n"
				"    uint     nHitsRegistered;\n"
				"    uint     nMissesRegistered;\n"
				"    HitProps hits[];\n"
				"};\n"
				"\n"
				"layout(location = 0) rayPayloadInEXT uint rayIndex;\n"
				"\n"
				"void main()\n"
				"{\n"
				"    atomicAdd(nMissesRegistered, 1);\n"
				"}\n";

			programCollection.glslSources.add("miss") << glu::MissSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				"layout(location = 0)              rayPayloadEXT uint               rayIndex;\n"
				"layout(set      = 0, binding = 1) uniform accelerationStructureEXT topLevelAS;\n"
				"\n"
				"void main()\n"
				"{\n"
				"    const uint nRaysPerInvocation = " + de::toString(m_nRaysPerInvocation) + ";\n"
				"\n"
				"    uint  nInvocation  = gl_LaunchIDEXT.z * gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;\n"
				"    uint  rayFlags     = 0;\n"
				"    float tmin         = 0.001;\n"
				"    float tmax         = 9.0;\n"
				"\n"
				"    if (nInvocation >= 256 / nRaysPerInvocation)\n"
				"    {\n"
				"        return;\n"
				"    }\n"
				"\n"
				"    for (uint nRay = 0; nRay < nRaysPerInvocation; ++nRay)\n"
				"    {\n"
				"        uint  cullMask     = 1 + nInvocation * nRaysPerInvocation + nRay;\n"
				"        uint  nCell        = nInvocation * nRaysPerInvocation + nRay;\n"
				"        uvec3 cellXYZ      = uvec3(nCell % gl_LaunchSizeEXT.x, (nCell / gl_LaunchSizeEXT.x) % gl_LaunchSizeEXT.y, (nCell / gl_LaunchSizeEXT.x / gl_LaunchSizeEXT.y) % gl_LaunchSizeEXT.z);\n"
				"        vec3  cellStartXYZ = vec3(cellXYZ) * vec3(2.0);\n"
				"        vec3  cellEndXYZ   = cellStartXYZ + vec3(1.0);\n"
				"        vec3  target       = mix(cellStartXYZ, cellEndXYZ, vec3(0.5) );\n"
				"        vec3  origin       = target - vec3(1, 1, 1);\n"
				"        vec3  direct       = normalize(target - origin);\n"
				"\n"
				"        if (nCell < 255)\n"
				"        {\n"
				"            rayIndex = nCell;"
				"\n"
				"            traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin, tmin, direct, tmax, 0);\n"
				"        }\n"
				"    }\n"
				"}\n";

			programCollection.glslSources.add("rgen") << glu::RaygenSource(css.str() ) << buildOptions;
		}
	}

	bool verifyResultBuffer (const void* resultDataPtr) const final
	{
		const deUint32* resultU32Ptr	= reinterpret_cast<const deUint32*>(resultDataPtr);
		const auto		nHitsReported	= *resultU32Ptr;
		const auto		nMissesReported	= *(resultU32Ptr + 1);
		bool			result			= true;

		// For each traced ray:
		//
		// 1. Exactly one ahit invocation per ray should be reported.
		// 2. All hits reported for a ray R should point to a primitive with a valid custom instance index
		// 3. The reported custom instance indices must be valid.
		std::map<deUint32, std::vector<deUint32> > customInstanceIndexToRayIndexVecMap;
		std::map<deUint32, std::vector<deUint32> > rayIndexToCustomInstanceIndexVecMap;

		typedef struct
		{
			deUint32 rayIndex;
			deUint32 customInstanceHit;
		} HitProperties;

		if (nHitsReported != 0xFF)
		{
			result = false;

			goto end;
		}

		if (nMissesReported != 0)
		{
			result = false;

			goto end;
		}

		for (deUint32 nHit = 0; nHit < nHitsReported; ++nHit)
		{
			const HitProperties* hitPropsPtr = reinterpret_cast<const HitProperties*>(resultU32Ptr + 2 /* preamble ints */ + nHit * 2 /* ints per HitProperties item */);

			customInstanceIndexToRayIndexVecMap[hitPropsPtr->customInstanceHit].push_back(hitPropsPtr->rayIndex);
			rayIndexToCustomInstanceIndexVecMap[hitPropsPtr->rayIndex].push_back         (hitPropsPtr->customInstanceHit);
		}

		if (static_cast<deUint32>(customInstanceIndexToRayIndexVecMap.size()) != nHitsReported)
		{
			/* Invalid number of unique custom instance indices reported. */
			result = false;

			goto end;
		}

		if (static_cast<deUint32>(rayIndexToCustomInstanceIndexVecMap.size()) != nHitsReported)
		{
			/* Invalid ray indices reported by ahit invocations */
			result = false;

			goto end;
		}

		for (const auto& currentItem : customInstanceIndexToRayIndexVecMap)
		{
			if (currentItem.second.size() != 1)
			{
				/* More than one ray associated with the same custom instance index */
				result = false;

				goto end;
			}

			if (currentItem.second.at(0) > 255)
			{
				/* Invalid ray index associated with the instance index */
				result = false;

				goto end;
			}

			if (std::find(	m_instanceCustomIndexVec.begin	(),
							m_instanceCustomIndexVec.end	(),
							currentItem.first)					== m_instanceCustomIndexVec.end() )
			{
				/* Invalid custom instance index reported for the ray */
				result = false;

				goto end;
			}
		}

		end:
			return result;
	}

private:

	const AccelerationStructureLayout	m_asLayout;
	const GeometryType					m_geometryType;
	const deUint32						m_nMaxHitsToRegister;
	const deUint32						m_nRaysPerInvocation;

	mutable std::vector<deUint32>	m_instanceCustomIndexVec;
	mutable deUint32				m_lastCustomInstanceIndexUsed;
	mutable deUint32				m_nCullMasksUsed;

	std::unique_ptr<GridASProvider>					m_asProviderPtr;
	std::unique_ptr<TopLevelAccelerationStructure>	m_tlPtr;
};



class MAXRayHitAttributeSizeTest: public TestBase
{
public:
	MAXRayHitAttributeSizeTest(	const GeometryType&					geometryType,
							const AccelerationStructureLayout&	asStructureLayout)
	:	m_asStructureLayout	(asStructureLayout),
		m_geometryType		(geometryType),
		m_gridSizeXYZ		(tcu::UVec3 (512, 1, 1) ),
		m_nRayAttributeU32s	(0)
	{
	}

	~MAXRayHitAttributeSizeTest()
	{
	/* Stub */
	}

	tcu::UVec3 getDispatchSize() const final
	{
		DE_ASSERT(m_gridSizeXYZ[0] != 0);
		DE_ASSERT(m_gridSizeXYZ[1] != 0);
		DE_ASSERT(m_gridSizeXYZ[2] != 0);

		return tcu::UVec3(m_gridSizeXYZ[0], m_gridSizeXYZ[1], m_gridSizeXYZ[2]);
	}

	deUint32 getResultBufferSize() const final
	{
		DE_ASSERT(m_gridSizeXYZ[0] != 0);
		DE_ASSERT(m_gridSizeXYZ[1] != 0);
		DE_ASSERT(m_gridSizeXYZ[2] != 0);

		return static_cast<deUint32>((3 /* nAHits, nCHits, nMisses */ + m_gridSizeXYZ[0] * m_gridSizeXYZ[1] * m_gridSizeXYZ[2] * m_nRayAttributeU32s * 2 /* stages where result data is stored */) * sizeof(deUint32) );
	}

	VkSpecializationInfo* getSpecializationInfoPtr(const VkShaderStageFlagBits& shaderStage) final
	{
		VkSpecializationInfo* resultPtr = nullptr;

		if (shaderStage == VK_SHADER_STAGE_INTERSECTION_BIT_KHR	||
			shaderStage == VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR	||
			shaderStage == VK_SHADER_STAGE_ANY_HIT_BIT_KHR)
		{
			resultPtr = &m_specializationInfo;
		}

		return resultPtr;
	}

	std::vector<TopLevelAccelerationStructure*>	getTLASPtrVecToBind() const final
	{
		DE_ASSERT(m_tlPtr != nullptr);

		return {m_tlPtr.get() };
	}

	void resetTLAS() final
	{
		m_tlPtr.reset();
	}

	bool init(RayTracingProperties*	rtPropertiesPtr) final
	{
		const auto maxRayHitAttributeSize = rtPropertiesPtr->getMaxRayHitAttributeSize();

		// TODO: If U8s are supported, we could cover the remaining space with these..
		m_nRayAttributeU32s = maxRayHitAttributeSize / static_cast<deUint32>(sizeof(deUint32) );
		DE_ASSERT(m_nRayAttributeU32s != 0);

		m_specializationInfoMapEntry.constantID = 1;
		m_specializationInfoMapEntry.offset		= 0;
		m_specializationInfoMapEntry.size		= sizeof(deUint32);

		m_specializationInfo.dataSize			= sizeof(deUint32);
		m_specializationInfo.mapEntryCount		= 1;
		m_specializationInfo.pData				= reinterpret_cast<const void*>(&m_nRayAttributeU32s);
		m_specializationInfo.pMapEntries		= &m_specializationInfoMapEntry;

		return true;
	}

	void initAS(vkt::Context&			context,
				RayTracingProperties*	/* rtPropertiesPtr */,
				VkCommandBuffer			commandBuffer) final
	{
		std::unique_ptr<GridASProvider> asProviderPtr(
			new GridASProvider(	tcu::Vec3 (0, 0, 0), /* gridStartXYZ          */
								tcu::Vec3 (1, 1, 1), /* gridCellSizeXYZ       */
								m_gridSizeXYZ,
								tcu::Vec3 (6, 0, 0), /* gridInterCellDeltaXYZ */
								m_geometryType)
		);

		m_tlPtr  = asProviderPtr->createTLAS(	context,
												m_asStructureLayout,
												commandBuffer,
												0,			/* bottomLevelGeometryFlags */
												nullptr,	/* optASPropertyProviderPtr */
												nullptr);	/* optASFeedbackPtr         */
	}

	void initPrograms(SourceCollections& programCollection) const final
	{
		const vk::ShaderBuildOptions	buildOptions(	programCollection.usedVulkanVersion,
														vk::SPIRV_VERSION_1_4,
														0u,		/* flags        */
														true);	/* allowSpirv14 */

		const char* constantDefinitions =
			"layout(constant_id = 1) const uint N_UINTS_IN_HIT_ATTRIBUTE = 1;\n";

		const char* hitAttributeDefinition =
			"\n"
			"hitAttributeEXT block\n"
			"{\n"
			"    uint values[N_UINTS_IN_HIT_ATTRIBUTE];\n"
			"};\n"
			"\n";

		const char* resultBufferDefinition =
			"layout(set      = 0, binding = 0, std430) buffer result\n"
			"{\n"
			"    uint nAHitsRegistered;\n"
			"    uint nCHitsRegistered;\n"
			"    uint nMissesRegistered;\n"
			"    uint retrievedValues[N_UINTS_IN_HIT_ATTRIBUTE];\n"
			"};\n";

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				+ de::toString(constantDefinitions)
				+ de::toString(hitAttributeDefinition) +
				"\n"
				"layout(location = 0) rayPayloadInEXT uint dummy;\n"
				+ de::toString(resultBufferDefinition) +
				"\n"
				"void main()\n"
				"{\n"
				"    atomicAdd(nAHitsRegistered, 1);\n"
				"\n"
				"    uint nInvocation = gl_LaunchIDEXT.z * gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;\n"
				"\n"
				"    for (uint nUint = 0; nUint < N_UINTS_IN_HIT_ATTRIBUTE; ++nUint)\n"
				"    {\n"
				"        retrievedValues[(2 * nInvocation + 1) * N_UINTS_IN_HIT_ATTRIBUTE + nUint] = values[nUint];\n"
				"    }\n"
				"}\n";

			programCollection.glslSources.add("ahit") << glu::AnyHitSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				+ de::toString(constantDefinitions)
				+ de::toString(hitAttributeDefinition) +
				  de::toString(resultBufferDefinition) +
				"\n"
				"layout(location = 0) rayPayloadInEXT uint rayIndex;\n"
				"\n"
				"void main()\n"
				"{\n"
				"    atomicAdd(nCHitsRegistered, 1);\n"
				"\n"
				"    uint nInvocation = gl_LaunchIDEXT.z * gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;\n"
				"\n"
				"    for (uint nUint = 0; nUint < N_UINTS_IN_HIT_ATTRIBUTE; ++nUint)\n"
				"    {\n"
				"        retrievedValues[(2 * nInvocation + 0) * N_UINTS_IN_HIT_ATTRIBUTE + nUint] = values[nUint];\n"
				"    }\n"
				"}\n";

			programCollection.glslSources.add("chit") << glu::ClosestHitSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				+ de::toString(constantDefinitions)
				+ de::toString(hitAttributeDefinition) +
				  de::toString(resultBufferDefinition) +
				"\n"
				"void main()\n"
				"{\n"
				"    uint nInvocation = gl_LaunchIDEXT.z * gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;\n"
				"\n"
				"    for (uint nUint = 0; nUint < N_UINTS_IN_HIT_ATTRIBUTE; ++nUint)\n"
				"    {\n"
				"        values[nUint] = 1 + nInvocation + nUint;\n"
				"    }\n"
				"\n"
				"    reportIntersectionEXT(0.95f, 0);\n"
				"}\n";

			programCollection.glslSources.add("intersection") << glu::IntersectionSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				+	de::toString(constantDefinitions)
				+	de::toString(resultBufferDefinition) +
				"\n"
				"void main()\n"
				"{\n"
				"    atomicAdd(nMissesRegistered, 1);\n"
				"}\n";

			programCollection.glslSources.add("miss") << glu::MissSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				"layout(location = 0)              rayPayloadEXT uint               dummy;\n"
				"layout(set      = 0, binding = 1) uniform accelerationStructureEXT accelerationStructure;\n"
				"\n"
				"void main()\n"
				"{\n"
				"    uint  nInvocation  = gl_LaunchIDEXT.z * gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;\n"
				"    uint  rayFlags     = 0;\n"
				"    float tmin         = 0.001;\n"
				"    float tmax         = 9.0;\n"
				"\n"
				"    uint  cullMask     = 0xFF;\n"
				"    vec3  cellStartXYZ = vec3(nInvocation * 3.0, 0.0, 0.0);\n"
				"    vec3  cellEndXYZ   = cellStartXYZ + vec3(1.0);\n"
				"    vec3  target       = mix(cellStartXYZ, cellEndXYZ, vec3(0.5) );\n"
				"    vec3  origin       = target - vec3(0, 2, 0);\n"
				"    vec3  direct       = normalize(target - origin);\n"
				"\n"
				"    traceRayEXT(accelerationStructure, rayFlags, cullMask, 0, 0, 0, origin, tmin, direct, tmax, 0);\n"
				"}\n";

			programCollection.glslSources.add("rgen") << glu::RaygenSource(css.str() ) << buildOptions;
		}
	}

	bool verifyResultBuffer (const void* resultDataPtr) const final
	{
		const deUint32* resultU32Ptr	= reinterpret_cast<const deUint32*>(resultDataPtr);
		bool			result			= false;


		const auto	nAHitsReported		= *resultU32Ptr;
		const auto	nCHitsRegistered	= *(resultU32Ptr + 1);
		const auto	nMissesRegistered	= *(resultU32Ptr + 2);

		if (nAHitsReported != m_gridSizeXYZ[0] * m_gridSizeXYZ[1] * m_gridSizeXYZ[2] / 2)
		{
			goto end;
		}

		if (nCHitsRegistered != nAHitsReported)
		{
			goto end;
		}

		if (nMissesRegistered != nAHitsReported)
		{
			goto end;
		}

		for (deUint32 nHit = 0; nHit < nAHitsReported; ++nHit)
		{
			const deUint32* ahitValues		= resultU32Ptr + 3 /* preamble ints */ + (2 * nHit + 0) * m_nRayAttributeU32s;
			const deUint32* chitValues		= resultU32Ptr + 3 /* preamble ints */ + (2 * nHit + 1) * m_nRayAttributeU32s;
			const bool		missExpected	= (nHit % 2) != 0;

			for (deUint32 nValue = 0; nValue < m_nRayAttributeU32s; ++nValue)
			{
				if (!missExpected)
				{
					if (ahitValues[nValue] != 1 + nHit + nValue)
					{
						goto end;
					}

					if (chitValues[nValue] != 1 + nHit + nValue)
					{
						goto end;
					}
				}
				else
				{
					if (ahitValues[nValue] != 0)
					{
						goto end;
					}

					if (chitValues[nValue] != 0)
					{
						goto end;
					}
				}
			}
		}

		result = true;
end:
		return result;
	}

private:

	const AccelerationStructureLayout	m_asStructureLayout;
	const GeometryType					m_geometryType;

	const tcu::UVec3								m_gridSizeXYZ;
	deUint32										m_nRayAttributeU32s;
	std::unique_ptr<TopLevelAccelerationStructure>	m_tlPtr;

	VkSpecializationInfo		m_specializationInfo;
	VkSpecializationMapEntry	m_specializationInfoMapEntry;
};

class NoDuplicateAnyHitTest : public TestBase
{
public:
	NoDuplicateAnyHitTest(	const AccelerationStructureLayout&	asLayout,
							const GeometryType&					geometryType)
		:m_asLayout			(asLayout),
		 m_geometryType		(geometryType),
		 m_gridSizeXYZ		(tcu::UVec3(4, 4, 4) ),
		 m_nRaysToTrace		(32)
	{
		/* Stub */
	}

	~NoDuplicateAnyHitTest()
	{
		/* Stub */
	}

	tcu::UVec3 getDispatchSize() const final
	{
		return tcu::UVec3(4, 4, m_nRaysToTrace / (4 * 4) + 1);
	}

	deUint32 getResultBufferSize() const final
	{
		const auto nPrimitives = m_gridSizeXYZ[0] * m_gridSizeXYZ[1] * m_gridSizeXYZ[2];

		return static_cast<deUint32>((2 /* nHits, nMisses */ + 3 * nPrimitives /* instancePrimitiveIDPairsUsed */) * sizeof(deUint32) * m_nRaysToTrace);
	}

	std::vector<TopLevelAccelerationStructure*>	getTLASPtrVecToBind() const	final
	{
		return {m_tlPtr.get() };
	}

	void resetTLAS() final
	{
		m_tlPtr.reset();
	}

	void initAS(vkt::Context&			context,
				RayTracingProperties*	/* rtPropertiesPtr */,
				VkCommandBuffer			commandBuffer) final
	{
		m_asProviderPtr.reset(
			new GridASProvider(	tcu::Vec3	(0,		0,		0),		/* gridStartXYZ          */
								tcu::Vec3	(1,		1,		1),		/* gridCellSizeXYZ       */
								m_gridSizeXYZ,
								tcu::Vec3	(2.0f,	2.0f,	2.0f),  /* gridInterCellDeltaXYZ */
								m_geometryType)
		);

		m_tlPtr  = m_asProviderPtr->createTLAS(	context,
												m_asLayout,
												commandBuffer,
												VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
												nullptr,	/* optASPropertyProviderPtr */
												nullptr);	/* optASFedbackPtr          */
	}

	void initPrograms(SourceCollections& programCollection) const final
	{
		const vk::ShaderBuildOptions	buildOptions(	programCollection.usedVulkanVersion,
														vk::SPIRV_VERSION_1_4,
														0u,		/* flags        */
														true);	/* allowSpirv14 */

		const auto nTotalPrimitives			= m_gridSizeXYZ[0] * m_gridSizeXYZ[1] * m_gridSizeXYZ[2];
		const auto hitPropertiesDefinition	=	"struct HitProperties\n"
												"{\n"
												"    uint nHitsRegistered;\n"
												"	 uint nMissRegistered;\n"
												"    uint instancePrimitiveIDPairsUsed[3 * " + de::toString(nTotalPrimitives) + "];\n"
												"};\n";

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				"hitAttributeEXT vec3 dummyAttribute;\n"
				"\n"
				+ hitPropertiesDefinition +
				"\n"
				"layout(location = 0) rayPayloadInEXT      dummy { vec3 dummyVec;};\n"
				"layout(set      = 0, binding = 0, std430) buffer result\n"
				"{\n"
				"    HitProperties rayToHitProps[" << de::toString(m_nRaysToTrace) << "];\n"
				"};\n"
				"\n"
				"void main()\n"
				"{\n"
				"    uint nRay            = gl_LaunchIDEXT.z * gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;\n"
				"    uint nHitsRegistered = atomicAdd(rayToHitProps[nRay].nHitsRegistered, 1);\n"
				"\n"
				"    rayToHitProps[nRay].instancePrimitiveIDPairsUsed[3 * nHitsRegistered + 0] = 1 + gl_InstanceID;\n"
				"    rayToHitProps[nRay].instancePrimitiveIDPairsUsed[3 * nHitsRegistered + 1] = 1 + gl_PrimitiveID;\n"
				"    rayToHitProps[nRay].instancePrimitiveIDPairsUsed[3 * nHitsRegistered + 2] = 1 + gl_GeometryIndexEXT;\n"
				"}\n";

			programCollection.glslSources.add("ahit") << glu::AnyHitSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				"hitAttributeEXT vec3 hitAttribute;\n"
				"\n"
				"void main()\n"
				"{\n"
				"    reportIntersectionEXT(0.95f, 0);\n"
				"}\n";

			programCollection.glslSources.add("intersection") << glu::IntersectionSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				+ hitPropertiesDefinition +
				"layout(location = 0) rayPayloadInEXT      vec3   dummy;\n"
				"layout(set      = 0, binding = 0, std430) buffer result\n"
				"{\n"
				"    HitProperties rayToHitProps[" << de::toString(m_nRaysToTrace) << "];\n"
				"};\n"
				"\n"
				"void main()\n"
				"{\n"
				"    uint nRay = gl_LaunchIDEXT.z * gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;\n"
				"\n"
				"    atomicAdd(rayToHitProps[nRay].nMissRegistered, 1);\n"
				"}\n";

			programCollection.glslSources.add("miss") << glu::MissSource(css.str() ) << buildOptions;
		}

		{
			std::stringstream css;

			css <<
				"#version 460 core\n"
				"\n"
				"#extension GL_EXT_ray_tracing : require\n"
				"\n"
				+ hitPropertiesDefinition +
				"layout(location = 0)              rayPayloadEXT vec3                     dummy;\n"
				"layout(set      = 0, binding = 1) uniform       accelerationStructureEXT topLevelAS;\n"
				"\n"
				"void main()\n"
				"{\n"
				"    uint  nInvocation = gl_LaunchIDEXT.z * gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;\n"
				"    uint  rayFlags    = 0;\n"
				"    uint  cullMask    = 0xFF;\n"
				"    float tmin        = 0.001;\n"
				"    float tmax        = 9.0;\n"
				"    vec3  origin      = vec3(4,                                  4,                                  4);\n"
				"    vec3  target      = vec3(float(gl_LaunchIDEXT.x * 2) + 0.5f, float(gl_LaunchIDEXT.y * 2) + 0.5f, float(gl_LaunchIDEXT.z * 2) + 0.5f);\n"
				"    vec3  direct      = normalize(target - origin);\n"
				"\n"
				"    if (nInvocation >= " << m_nRaysToTrace << ")\n"
				"    {\n"
				"        return;\n"
				"    }\n"
				"\n"
				"    traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin, tmin, direct, tmax, 0);\n"
				"}\n";

			programCollection.glslSources.add("rgen") << glu::RaygenSource(css.str() ) << buildOptions;
		}
	}

	bool verifyResultBuffer (const void* resultDataPtr) const final
	{
		const auto	nTotalPrimitives	= m_gridSizeXYZ[0] * m_gridSizeXYZ[1] * m_gridSizeXYZ[2];
		bool		result				= true;

		for (deUint32 nRay = 0; nRay < m_nRaysToTrace; ++nRay)
		{
			std::vector<std::tuple<deUint32, deUint32, deUint32> >	tupleVec;
			const auto												rayProps	= reinterpret_cast<const deUint32*>(resultDataPtr) + (2 + 3 * nTotalPrimitives) * nRay;

			// 1. At least one ahit invocation must have been made.
			if (rayProps[0] == 0)
			{
				result = false;

				goto end;
			}

			// 2. It's OK for each ray to intersect many AABBs, but no AABB should have had >1 ahit invocation fired.
			for (deUint32 nPrimitive = 0; nPrimitive < nTotalPrimitives; nPrimitive++)
			{
				const auto instanceID    = rayProps[2 /* nHits, nMissesRegistered */ + 3 * nPrimitive + 0];
				const auto primitiveID   = rayProps[2 /* nHits, nMissesRegistered */ + 3 * nPrimitive + 1];
				const auto geometryIndex = rayProps[2 /* nHits, nMissesRegistered */ + 3 * nPrimitive + 2];

				const auto currentTuple = std::tuple<deUint32, deUint32, deUint32>(instanceID, primitiveID, geometryIndex);

				if (instanceID		!= 0 ||
					primitiveID		!= 0 ||
					geometryIndex	!= 0)
				{
					if (std::find(	tupleVec.begin(),
									tupleVec.end  (),
									currentTuple) != tupleVec.end() )
					{
						result = false;

						goto end;
					}

					tupleVec.push_back(currentTuple);
				}
			}

			// 3. None of the traced rays should have triggered the miss shader invocation.
			if (rayProps[1] != 0)
			{
				result = false;

				goto end;
			}
		}

		end:
			return result;
	}

private:
	const AccelerationStructureLayout	m_asLayout;
	const GeometryType					m_geometryType;
	const tcu::UVec3					m_gridSizeXYZ;
	const deUint32						m_nRaysToTrace;

	std::unique_ptr<GridASProvider>					m_asProviderPtr;
	std::unique_ptr<TopLevelAccelerationStructure>	m_tlPtr;
};


/* Generic misc test instance */
class RayTracingMiscTestInstance : public TestInstance
{
public:
	 RayTracingMiscTestInstance (	Context&				context,
									const CaseDef&			data,
									TestBase*				testPtr);
	~RayTracingMiscTestInstance (	void);

	bool			init	(void);
	tcu::TestStatus	iterate	(void);

protected:
	void							checkSupport(void) const;
	de::MovePtr<BufferWithMemory>	runTest		(void);

private:
	CaseDef	m_data;

	de::MovePtr<RayTracingProperties>	m_rayTracingPropsPtr;
	TestBase*							m_testPtr;
};

RayTracingMiscTestInstance::RayTracingMiscTestInstance (Context&					context,
														const CaseDef&				data,
														TestBase*					testPtr)
	: vkt::TestInstance	(context)
	, m_data			(data)
	, m_testPtr			(testPtr)
{
}

RayTracingMiscTestInstance::~RayTracingMiscTestInstance(void)
{
	/* Stub */
}

bool RayTracingMiscTestInstance::init()
{
	const auto& instanceInterface = m_context.getInstanceInterface();
	const auto& physicalDeviceVk  = m_context.getPhysicalDevice   ();

	m_rayTracingPropsPtr = makeRayTracingProperties(instanceInterface,
													physicalDeviceVk);

	return true;
}

de::MovePtr<BufferWithMemory> RayTracingMiscTestInstance::runTest(void)
{
	const DeviceInterface&		deviceInterface		= m_context.getDeviceInterface	();
	const VkDevice				deviceVk			= m_context.getDevice			();

	const deUint32			queueFamilyIndex	= m_context.getUniversalQueueFamilyIndex();
	const VkQueue			queueVk				= m_context.getUniversalQueue			();
	Allocator&				allocator			= m_context.getDefaultAllocator			();

	de::MovePtr<BufferWithMemory>					resultBufferPtr;
	auto											rtPropertiesPtr		= makeRayTracingProperties(m_context.getInstanceInterface(), m_context.getPhysicalDevice() );
	std::unique_ptr<TopLevelAccelerationStructure>	tlPtr;

	m_testPtr->init(rtPropertiesPtr.get() );

	const auto resultBufferSize	= m_testPtr->getResultBufferSize();


	const Move<VkDescriptorSetLayout>	descriptorSetLayoutPtr	= DescriptorSetLayoutBuilder()
																	.addSingleBinding(	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
																						ALL_RAY_TRACING_STAGES)
																	.addArrayBinding(	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,
																						m_testPtr->getASBindingArraySize(),
																						ALL_RAY_TRACING_STAGES)
																	.build			(	deviceInterface,
																						deviceVk);

	const Move<VkDescriptorPool>		descriptorPoolPtr		= DescriptorPoolBuilder()
																	.addType(	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER)
																	.addType(	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,
																				m_testPtr->getASBindingArraySize() )
																	.build	(	deviceInterface,
																				deviceVk,
																				VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
																				1u); /* maxSets */

	const Move<VkDescriptorSet>			descriptorSetPtr		= makeDescriptorSet(deviceInterface,
																					deviceVk,
																					*descriptorPoolPtr,
																					*descriptorSetLayoutPtr);

	const Move<VkPipelineLayout>		pipelineLayoutPtr		= m_testPtr->getPipelineLayout(	deviceInterface,
																								deviceVk,
																								descriptorSetLayoutPtr.get() );

	const Move<VkCommandPool>			cmdPoolPtr				= createCommandPool(deviceInterface,
																					deviceVk,
																					0, /* pCreateInfo */
																					queueFamilyIndex);

	const Move<VkCommandBuffer>			cmdBufferPtr			= allocateCommandBuffer(deviceInterface,
																						deviceVk,
																						*cmdPoolPtr,
																						VK_COMMAND_BUFFER_LEVEL_PRIMARY);

	Move<VkPipeline>					pipelineVkPtr;
	de::MovePtr<RayTracingPipeline>		rayTracingPipelinePtr	= de::newMovePtr<RayTracingPipeline>();

	{
		auto& collection = m_context.getBinaryCollection();

		Move<VkShaderModule>	raygenShader		= createShaderModule(	deviceInterface,
																			deviceVk,
																			collection.get("rgen"),
																			0); /* flags */
		Move<VkShaderModule>	missShader			= createShaderModule(	deviceInterface,
																			deviceVk,
																			collection.get("miss"),
																			0); /* flags */

		rayTracingPipelinePtr->addShader(	VK_SHADER_STAGE_RAYGEN_BIT_KHR,
											makeVkSharedPtr(raygenShader),
											static_cast<deUint32>(ShaderGroups::RAYGEN_GROUP),
											m_testPtr->getSpecializationInfoPtr(VK_SHADER_STAGE_RAYGEN_BIT_KHR) );

		if (collection.contains("ahit") )
		{
			Move<VkShaderModule>	anyHitShader	= createShaderModule(	deviceInterface,
																			deviceVk,
																			collection.get("ahit"),
																			0); /* flags */

			rayTracingPipelinePtr->addShader(	VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
												makeVkSharedPtr(anyHitShader),
												static_cast<deUint32>(ShaderGroups::HIT_GROUP),
												m_testPtr->getSpecializationInfoPtr(VK_SHADER_STAGE_ANY_HIT_BIT_KHR) );
		}

		if (collection.contains("chit") )
		{
			Move<VkShaderModule>	closestHitShader	= createShaderModule(	deviceInterface,
																				deviceVk,
																				collection.get("chit"),
																				0); /* flags */

			rayTracingPipelinePtr->addShader(	VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
												makeVkSharedPtr(closestHitShader),
												static_cast<deUint32>(ShaderGroups::HIT_GROUP),
												m_testPtr->getSpecializationInfoPtr(VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR) );
		}

		rayTracingPipelinePtr->addShader(	VK_SHADER_STAGE_MISS_BIT_KHR,
											makeVkSharedPtr(missShader),
											static_cast<deUint32>(ShaderGroups::MISS_GROUP),
											m_testPtr->getSpecializationInfoPtr(VK_SHADER_STAGE_MISS_BIT_KHR) );

		if (m_data.geometryType == GeometryType::AABB				||
			m_data.geometryType == GeometryType::AABB_AND_TRIANGLES)
		{
			Move<VkShaderModule>	intersectionShader	= createShaderModule(	deviceInterface,
																				deviceVk,
																				collection.get("intersection"),
																				0); /* flags */

			rayTracingPipelinePtr->addShader(	VK_SHADER_STAGE_INTERSECTION_BIT_KHR,
												makeVkSharedPtr(intersectionShader),
												static_cast<deUint32>(ShaderGroups::HIT_GROUP),
												m_testPtr->getSpecializationInfoPtr(VK_SHADER_STAGE_INTERSECTION_BIT_KHR) );
		}

		pipelineVkPtr = rayTracingPipelinePtr->createPipeline(	deviceInterface,
																deviceVk,
																*pipelineLayoutPtr);
	}

	const auto raygenShaderBindingTablePtr	= rayTracingPipelinePtr->createShaderBindingTable(	deviceInterface,
																								deviceVk,
																								*pipelineVkPtr,
																								allocator,
																								m_rayTracingPropsPtr->getShaderGroupHandleSize		(),
																								m_rayTracingPropsPtr->getShaderGroupBaseAlignment	(),
																								static_cast<deUint32>								(ShaderGroups::RAYGEN_GROUP),
																								1u); /* groupCount */
	const auto	missShaderBindingTablePtr	= rayTracingPipelinePtr->createShaderBindingTable(	deviceInterface,
																								deviceVk,
																								*pipelineVkPtr,
																								allocator,
																								m_rayTracingPropsPtr->getShaderGroupHandleSize		(),
																								m_rayTracingPropsPtr->getShaderGroupBaseAlignment	(),
																								static_cast<deUint32>								(ShaderGroups::MISS_GROUP),
																								1u); /* groupCount */
	const auto	hitShaderBindingTablePtr	= rayTracingPipelinePtr->createShaderBindingTable(	deviceInterface,
																								deviceVk,
																								*pipelineVkPtr,
																								allocator,
																								m_rayTracingPropsPtr->getShaderGroupHandleSize		(),
																								m_rayTracingPropsPtr->getShaderGroupBaseAlignment	(),
																								static_cast<deUint32>								(ShaderGroups::HIT_GROUP),
																								1u); /* groupCount */

	{
		const auto resultBufferCreateInfo	= makeBufferCreateInfo(	resultBufferSize,
																	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT);

		resultBufferPtr	= de::MovePtr<BufferWithMemory>(
			new BufferWithMemory(	deviceInterface,
									deviceVk,
									allocator,
									resultBufferCreateInfo,
									MemoryRequirement::HostVisible));
	}

	beginCommandBuffer(	deviceInterface,
						*cmdBufferPtr,
						0u /* flags */);
	{
		m_testPtr->initAS(	m_context,
							rtPropertiesPtr.get(),
							*cmdBufferPtr);

		std::vector<TopLevelAccelerationStructure*> tlasPtrVec = m_testPtr->getTLASPtrVecToBind();
		std::vector<VkAccelerationStructureKHR>		tlasVkVec;

		for (auto& currentTLASPtr : tlasPtrVec)
		{
			tlasVkVec.push_back(*currentTLASPtr->getPtr() );
		}

		deviceInterface.cmdFillBuffer(	*cmdBufferPtr,
										**resultBufferPtr,
										0,					/* dstOffset */
										VK_WHOLE_SIZE,
										0);					/* data */

		{
			const auto postFillBarrier = makeBufferMemoryBarrier(	VK_ACCESS_TRANSFER_WRITE_BIT,	/* srcAccessMask */
																	VK_ACCESS_SHADER_WRITE_BIT,		/* dstAccessMask */
																	**resultBufferPtr,
																	0, /* offset */
																	VK_WHOLE_SIZE);

			cmdPipelineBufferMemoryBarrier(	deviceInterface,
											*cmdBufferPtr,
											VK_PIPELINE_STAGE_TRANSFER_BIT,					/* srcStageMask */
											VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,	/* dstStageMask */
											&postFillBarrier);
		}

		{
			VkWriteDescriptorSetAccelerationStructureKHR accelerationStructureWriteDescriptorSet =
			{
				VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,	//  VkStructureType						sType;
				DE_NULL,															//  const void*							pNext;
				static_cast<deUint32>(tlasVkVec.size() ),							//  deUint32							accelerationStructureCount;
				tlasVkVec.data(),													//  const VkAccelerationStructureKHR*	pAccelerationStructures;
			};

			const auto descriptorResultBufferInfo = makeDescriptorBufferInfo(	**resultBufferPtr,
																				0, /* offset */
																				resultBufferSize);

			DescriptorSetUpdateBuilder()
				.writeSingle(	*descriptorSetPtr,
								DescriptorSetUpdateBuilder::Location::binding(0u),
								VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
								&descriptorResultBufferInfo)
				.writeArray(	*descriptorSetPtr,
								DescriptorSetUpdateBuilder::Location::binding(1u),
								VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,
								static_cast<deUint32>(tlasVkVec.size() ),
								&accelerationStructureWriteDescriptorSet)
				.update		(	deviceInterface,
								deviceVk);
		}

		deviceInterface.cmdBindDescriptorSets(	*cmdBufferPtr,
												VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR,
												*pipelineLayoutPtr,
												0, /* firstSet           */
												1, /* descriptorSetCount */
												&descriptorSetPtr.get(),
												0,        /* dynamicOffsetCount */
												DE_NULL); /* pDynamicOffsets    */

		deviceInterface.cmdBindPipeline(*cmdBufferPtr,
										VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR,
										*pipelineVkPtr);

		{
			const auto preTraceMemoryBarrier	= makeMemoryBarrier(VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,	/* srcAccessMask */
																	VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR);	/* dstAccessMask */

			cmdPipelineMemoryBarrier(	deviceInterface,
										*cmdBufferPtr,
										VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,	/* srcStageMask */
										VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,			/* dstStageMask */
										&preTraceMemoryBarrier);
		}

		{
			const auto	nTraceRaysInvocationsNeeded			= m_testPtr->getNTraceRayInvocationsNeeded();
			const auto	raygenShaderBindingTableRegion		= makeStridedDeviceAddressRegionKHR(getBufferDeviceAddress(	deviceInterface,
																														deviceVk,
																														raygenShaderBindingTablePtr->get(),
																														0 /* offset */),
																								m_rayTracingPropsPtr->getShaderGroupHandleSize(),
																								m_rayTracingPropsPtr->getShaderGroupHandleSize() );
			const auto	missShaderBindingTableRegion		= makeStridedDeviceAddressRegionKHR(getBufferDeviceAddress(	deviceInterface,
																														deviceVk,
																														missShaderBindingTablePtr->get(),
																														0 /* offset */),
																								m_rayTracingPropsPtr->getShaderGroupHandleSize(),
																								m_rayTracingPropsPtr->getShaderGroupHandleSize() );
			const auto	hitShaderBindingTableRegion			= makeStridedDeviceAddressRegionKHR(getBufferDeviceAddress(	deviceInterface,
																														deviceVk,
																														hitShaderBindingTablePtr->get(),
																														0 /* offset */),
																								m_rayTracingPropsPtr->getShaderGroupHandleSize(),
																								m_rayTracingPropsPtr->getShaderGroupHandleSize() );
			const auto	callableShaderBindingTableRegion	= makeStridedDeviceAddressRegionKHR(DE_NULL,
																								0, /* stride */
																								0  /* size   */);

			for (deUint32 nInvocation = 0; nInvocation < nTraceRaysInvocationsNeeded; ++nInvocation)
			{
				m_testPtr->onBeforeCmdTraceRays(nInvocation,
												m_context,
												*cmdBufferPtr,
												*pipelineLayoutPtr);

				cmdTraceRays(	deviceInterface,
								*cmdBufferPtr,
								&raygenShaderBindingTableRegion,
								&missShaderBindingTableRegion,
								&hitShaderBindingTableRegion,
								&callableShaderBindingTableRegion,
								m_testPtr->getDispatchSize()[0],
								m_testPtr->getDispatchSize()[1],
								m_testPtr->getDispatchSize()[2]);
			}
		}

		{
			const auto postTraceMemoryBarrier	= makeMemoryBarrier(VK_ACCESS_SHADER_WRITE_BIT,	/* srcAccessMask */
																	VK_ACCESS_HOST_READ_BIT);	/* dstAccessMask */

			cmdPipelineMemoryBarrier(	deviceInterface,
										*cmdBufferPtr,
										VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,	/* srcStageMask */
										VK_PIPELINE_STAGE_HOST_BIT,						/* dstStageMask */
										&postTraceMemoryBarrier);
		}
	}
	endCommandBuffer(deviceInterface,
					*cmdBufferPtr);

	submitCommandsAndWait(	deviceInterface,
							deviceVk,
							queueVk,
							cmdBufferPtr.get() );

	invalidateMappedMemoryRange(deviceInterface,
								deviceVk,
								resultBufferPtr->getAllocation().getMemory(),
								resultBufferPtr->getAllocation().getOffset(),
								resultBufferSize);

	m_testPtr->resetTLAS();

	return resultBufferPtr;
}

tcu::TestStatus RayTracingMiscTestInstance::iterate (void)
{
	const de::MovePtr<BufferWithMemory>	bufferGPUPtr		= runTest();
	const deUint32*						bufferGPUDataPtr	= (deUint32*) bufferGPUPtr->getAllocation().getHostPtr();
	const bool							result				= m_testPtr->verifyResultBuffer(bufferGPUDataPtr);

	if (result)
		return tcu::TestStatus::pass("Pass");
	else
		return tcu::TestStatus::fail("Fail");
}

}	// anonymous


class RayTracingTestCase : public TestCase
{
	public:
							 RayTracingTestCase	(	tcu::TestContext&	context,
													const char*			name,
													const char*			desc,
													const CaseDef		data);
							~RayTracingTestCase	(	void);

	virtual void			checkSupport		(Context&			context)			const final;
	virtual TestInstance*	createInstance		(Context&			context)			const final;
	void					initPrograms		(SourceCollections& programCollection)	const final;

private:
	CaseDef								m_data;
	mutable std::unique_ptr<TestBase>	m_testPtr;
};

RayTracingTestCase::RayTracingTestCase (tcu::TestContext&	context,
										const char*			name,
										const char*			desc,
										const CaseDef		data)
	: vkt::TestCase	(	context,
						name,
						desc)
	, m_data		(	data)
{
}

RayTracingTestCase::~RayTracingTestCase	(void)
{
}

void RayTracingTestCase::checkSupport(Context& context) const
{
	context.requireDeviceFunctionality("VK_KHR_acceleration_structure");
	context.requireDeviceFunctionality("VK_KHR_buffer_device_address");
	context.requireDeviceFunctionality("VK_KHR_deferred_host_operations");
	context.requireDeviceFunctionality("VK_KHR_ray_tracing_pipeline");

	const VkPhysicalDeviceAccelerationStructureFeaturesKHR&	accelerationStructureFeaturesKHR	= context.getAccelerationStructureFeatures	();
	const VkPhysicalDeviceRayTracingPipelineFeaturesKHR&	rayTracingPipelineFeaturesKHR		= context.getRayTracingPipelineFeatures		();

	if (rayTracingPipelineFeaturesKHR.rayTracingPipeline == DE_FALSE)
	{
		TCU_THROW(NotSupportedError, "VkPhysicalDeviceRayTracingPipelineFeaturesKHR::rayTracingPipeline is false");
	}

	if (accelerationStructureFeaturesKHR.accelerationStructure == DE_FALSE)
	{
		TCU_THROW(NotSupportedError, "VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructure is false");
	}
}

void RayTracingTestCase::initPrograms(SourceCollections& programCollection)	const
{
	switch (m_data.type)
	{
		case TestType::AABBS_AND_TRIS_IN_ONE_TL:
		{
			m_testPtr.reset(
				new AABBTriTLTest(m_data.geometryType, m_data.asLayout)
			);

			m_testPtr->initPrograms(programCollection);

			break;
		}

		case TestType::AS_STRESS_TEST:
		{
			m_testPtr.reset(
				new ASStressTest(m_data.geometryType, m_data.asLayout)
			);

			m_testPtr->initPrograms(programCollection);

			break;
		}

		case TestType::CULL_MASK:
		{
			m_testPtr.reset(
				new CullMaskTest(m_data.asLayout, m_data.geometryType)
			);

			m_testPtr->initPrograms(programCollection);

			break;
		}

		case TestType::MAX_RAY_HIT_ATTRIBUTE_SIZE:
		{
			m_testPtr.reset(
				new MAXRayHitAttributeSizeTest(m_data.geometryType, m_data.asLayout)
			);

			m_testPtr->initPrograms(programCollection);

			break;
		}

		case TestType::NO_DUPLICATE_ANY_HIT:
		{
			m_testPtr.reset(
				new NoDuplicateAnyHitTest(m_data.asLayout, m_data.geometryType)
			);

			m_testPtr->initPrograms(programCollection);

			break;
		}

		default:
		{
			deAssertFail(	"This location should never be reached",
							__FILE__,
							__LINE__);
		}
	}
}

TestInstance* RayTracingTestCase::createInstance (Context& context) const
{
	switch (m_data.type)
	{
		case TestType::AABBS_AND_TRIS_IN_ONE_TL:
		{
			if (m_testPtr == nullptr)
			{
				m_testPtr.reset(
					new AABBTriTLTest(m_data.geometryType, m_data.asLayout)
				);
			}

			break;
		}

		case TestType::AS_STRESS_TEST:
		{
			if (m_testPtr == nullptr)
			{
				m_testPtr.reset(
					new ASStressTest(m_data.geometryType, m_data.asLayout)
				);
			}

			break;
		}

		case TestType::CULL_MASK:
		{
			if (m_testPtr == nullptr)
			{
				m_testPtr.reset(
					new CullMaskTest(m_data.asLayout, m_data.geometryType)
				);
			}

			break;
		}

		case TestType::MAX_RAY_HIT_ATTRIBUTE_SIZE:
		{
			if (m_testPtr == nullptr)
			{
				m_testPtr.reset(
					new MAXRayHitAttributeSizeTest(m_data.geometryType, m_data.asLayout)
				);
			}

			break;
		}

		case TestType::NO_DUPLICATE_ANY_HIT:
		{
			if (m_testPtr == nullptr)
			{
				m_testPtr.reset(
					new NoDuplicateAnyHitTest(m_data.asLayout, m_data.geometryType)
				);
			}

			break;
		}

		default:
		{
			deAssertFail(	"This location should never be reached",
							__FILE__,
							__LINE__);
		}
	}

	auto newTestInstancePtr = new RayTracingMiscTestInstance(	context,
																m_data,
																m_testPtr.get		() );

	newTestInstancePtr->init();

	return newTestInstancePtr;
}


tcu::TestCaseGroup*	createMiscTests (tcu::TestContext& testCtx)
{
	de::MovePtr<tcu::TestCaseGroup> miscGroupPtr(
		new tcu::TestCaseGroup(
			testCtx,
			"misc",
			"Miscellaneous ray-tracing tests"));

	for (auto currentGeometryType = GeometryType::FIRST; currentGeometryType != GeometryType::COUNT; currentGeometryType = static_cast<GeometryType>(static_cast<deUint32>(currentGeometryType) + 1) )
	{
		const std::string newTestCaseName = "AS_stresstest_" + de::toString(getSuffixForGeometryType(currentGeometryType) );

		auto newTestCasePtr = new RayTracingTestCase(	testCtx,
														newTestCaseName.data(),
														"Verifies raygen shader invocations can simultaneously access as many AS instances as reported",
														CaseDef{TestType::AS_STRESS_TEST, currentGeometryType, AccelerationStructureLayout::ONE_TL_MANY_BLS_ONE_GEOMETRY});

		miscGroupPtr->addChild(newTestCasePtr);
	}

	for (auto currentGeometryType = GeometryType::FIRST; currentGeometryType != GeometryType::COUNT; currentGeometryType = static_cast<GeometryType>(static_cast<deUint32>(currentGeometryType) + 1) )
	{
		const std::string newTestCaseName = "cullmask_" + de::toString(getSuffixForGeometryType(currentGeometryType) );

		auto newTestCasePtr = new RayTracingTestCase(	testCtx,
														newTestCaseName.data(),
														"Verifies cull mask works as specified",
														CaseDef{TestType::CULL_MASK, currentGeometryType, AccelerationStructureLayout::ONE_TL_MANY_BLS_ONE_GEOMETRY});

		miscGroupPtr->addChild(newTestCasePtr);
	}

	for (auto currentGeometryType = GeometryType::FIRST; currentGeometryType != GeometryType::COUNT; currentGeometryType = static_cast<GeometryType>(static_cast<deUint32>(currentGeometryType) + 1) )
	{
		for (auto currentASLayout = AccelerationStructureLayout::FIRST; currentASLayout != AccelerationStructureLayout::COUNT; currentASLayout = static_cast<AccelerationStructureLayout>(static_cast<deUint32>(currentASLayout) + 1) )
		{
			const std::string newTestCaseName = "NO_DUPLICATE_ANY_HIT_" + de::toString(getSuffixForASLayout(currentASLayout) ) + "_" + de::toString(getSuffixForGeometryType(currentGeometryType) );

			auto newTestCasePtr = new RayTracingTestCase(	testCtx,
															newTestCaseName.data(),
															"Verifies the NO_DUPLICATE_ANY_HIT flag is adhered to when tracing rays",
															CaseDef{TestType::NO_DUPLICATE_ANY_HIT, currentGeometryType, currentASLayout});

			miscGroupPtr->addChild(newTestCasePtr);
		}
	}

	{
		auto newTestCasePtr = new RayTracingTestCase(	testCtx,
														"mixedPrimTL",
														"Verifies top-level acceleration structures built of AABB and triangle bottom-level AS instances work as expected",
														CaseDef{TestType::AABBS_AND_TRIS_IN_ONE_TL, GeometryType::AABB_AND_TRIANGLES, AccelerationStructureLayout::ONE_TL_MANY_BLS_MANY_GEOMETRIES_WITH_VARYING_PRIM_TYPES});

		miscGroupPtr->addChild(newTestCasePtr);
	}

	for (auto currentASLayout = AccelerationStructureLayout::FIRST; currentASLayout != AccelerationStructureLayout::COUNT; currentASLayout = static_cast<AccelerationStructureLayout>(static_cast<deUint32>(currentASLayout) + 1) )
	{
		const std::string newTestCaseName = "maxrayhitattributesize_" + de::toString(getSuffixForASLayout(currentASLayout) );

		auto newTestCasePtr = new RayTracingTestCase(	testCtx,
														newTestCaseName.data(),
														"Verifies that the maximum ray hit attribute size property reported by the implementation is actually supported.",
														CaseDef{TestType::MAX_RAY_HIT_ATTRIBUTE_SIZE, GeometryType::AABB, AccelerationStructureLayout::ONE_TL_ONE_BL_ONE_GEOMETRY});

		miscGroupPtr->addChild(newTestCasePtr);
	}

	return miscGroupPtr.release();
}

}	// RayTracing
}	// vkt
